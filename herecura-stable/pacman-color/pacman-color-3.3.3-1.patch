diff -Naur pacman-3.3.3/src/pacman/callback.c pacman-color-3.3.3/src/pacman/callback.c
--- pacman-3.3.3/src/pacman/callback.c	2009-10-04 16:30:00.000000000 +0200
+++ pacman-color-3.3.3/src/pacman/callback.c	2009-11-11 17:38:37.000000000 +0100
@@ -217,16 +217,16 @@
 			printf(_("generating %s with %s... "), (char *)data1, (char *)data2);
 			break;
 		case PM_TRANS_EVT_DELTA_PATCH_DONE:
-			printf(_("success!\n"));
+			color_printf(COLOR_GREEN_ALL, _("success!\n"));
 			break;
 		case PM_TRANS_EVT_DELTA_PATCH_FAILED:
-			printf(_("failed.\n"));
+			color_printf(COLOR_RED_ALL, _("failed.\n"));
 			break;
 		case PM_TRANS_EVT_SCRIPTLET_INFO:
 			printf("%s", (char*)data1);
 			break;
 		case PM_TRANS_EVT_RETRIEVE_START:
-			printf(_(":: Retrieving packages from %s...\n"), (char*)data1);
+			color_printf(COLOR_DOUBLECOLON, _(":: Retrieving packages from %s...\n"), (char*)data1);
 			break;
 		/* all the simple done events, with fallthrough for each */
 		case PM_TRANS_EVT_FILECONFLICTS_DONE:
@@ -249,17 +249,17 @@
 {
 	switch(event) {
 		case PM_TRANS_CONV_INSTALL_IGNOREPKG:
-			*response = yesno(_(":: %s is in IgnorePkg/IgnoreGroup. Install anyway?"),
+			*response = yesno(COLOR_DOUBLECOLON, _(":: %s is in IgnorePkg/IgnoreGroup. Install anyway?"),
 							  alpm_pkg_get_name(data1));
 			break;
 		case PM_TRANS_CONV_REPLACE_PKG:
-			*response = yesno(_(":: Replace %s with %s/%s?"),
+			*response = yesno(COLOR_DOUBLECOLON, _(":: Replace %s with %s/%s?"),
 					alpm_pkg_get_name(data1),
 					(char *)data3,
 					alpm_pkg_get_name(data2));
 			break;
 		case PM_TRANS_CONV_CONFLICT_PKG:
-			*response = yesno(_(":: %s conflicts with %s. Remove %s?"),
+			*response = yesno(COLOR_DOUBLECOLON, _(":: %s conflicts with %s. Remove %s?"),
 					(char *)data1,
 					(char *)data2,
 					(char *)data2);
@@ -272,17 +272,17 @@
 					namelist = alpm_list_add(namelist,
 							(char *)alpm_pkg_get_name(i->data));
 				}
-				printf(_(":: the following package(s) cannot be upgraded due to "
+				color_printf(COLOR_DOUBLECOLON, _(":: the following package(s) cannot be upgraded due to "
 						"unresolvable dependencies:\n"));
-				list_display("     ", namelist);
-				*response = yesno(_("\nDo you want to skip the above "
+				list_display(NULL, "     ", namelist);
+				*response = yesno(NULL, _("\nDo you want to skip the above "
 							"package(s) for this upgrade?"));
 				alpm_list_free(namelist);
 			}
 			break;
 		case PM_TRANS_CONV_LOCAL_NEWER:
 			if(!config->op_s_downloadonly) {
-				*response = yesno(_(":: %s-%s: local version is newer. Upgrade anyway?"),
+				*response = yesno(COLOR_DOUBLECOLON, _(":: %s-%s: local version is newer. Upgrade anyway?"),
 						alpm_pkg_get_name(data1),
 						alpm_pkg_get_version(data1));
 			} else {
@@ -290,7 +290,7 @@
 			}
 			break;
 		case PM_TRANS_CONV_CORRUPTED_PKG:
-			*response = yesno(_(":: File %s is corrupted. Do you want to delete it?"),
+			*response = yesno(COLOR_DOUBLECOLON, _(":: File %s is corrupted. Do you want to delete it?"),
 					(char *)data1);
 			break;
 	}
@@ -397,8 +397,8 @@
 
 	}
 
-	printf("(%*d/%*d) %ls%-*s", digits, remain, digits, howmany,
-			wcstr, padwid, "");
+	color_printf(COLOR_BLUE_ALL, "(%*d/%*d)", digits, remain, digits, howmany);
+	printf(" %ls%-*s", wcstr, padwid, "");
 
 	free(wcstr);
 
diff -Naur pacman-3.3.3/src/pacman/package.c pacman-color-3.3.3/src/pacman/package.c
--- pacman-3.3.3/src/pacman/package.c	2009-09-30 03:38:22.000000000 +0200
+++ pacman-color-3.3.3/src/pacman/package.c	2009-11-11 17:38:37.000000000 +0100
@@ -89,49 +89,48 @@
 	}
 
 	/* actual output */
-	string_display(_("Name           :"), alpm_pkg_get_name(pkg));
-	string_display(_("Version        :"), alpm_pkg_get_version(pkg));
-	string_display(_("URL            :"), alpm_pkg_get_url(pkg));
-	list_display(_("Licenses       :"), alpm_pkg_get_licenses(pkg));
-	list_display(_("Groups         :"), alpm_pkg_get_groups(pkg));
-	list_display(_("Provides       :"), alpm_pkg_get_provides(pkg));
-	list_display(_("Depends On     :"), depstrings);
-	list_display_linebreak(_("Optional Deps  :"), alpm_pkg_get_optdepends(pkg));
+	color_string_display(COLOR_WHITE_ALL, _("Name           :"), COLOR_WHITE_ALL, alpm_pkg_get_name(pkg));
+	color_string_display(COLOR_WHITE_ALL, _("Version        :"), COLOR_GREEN_ALL, alpm_pkg_get_version(pkg));
+	color_string_display(COLOR_WHITE_ALL, _("URL            :"), COLOR_CYAN_ALL, alpm_pkg_get_url(pkg));
+	list_display(COLOR_WHITE_ALL, _("Licenses       :"), alpm_pkg_get_licenses(pkg));
+	list_display(COLOR_WHITE_ALL, _("Groups         :"), alpm_pkg_get_groups(pkg));
+	list_display(COLOR_WHITE_ALL, _("Provides       :"), alpm_pkg_get_provides(pkg));
+	list_display(COLOR_WHITE_ALL, _("Depends On     :"), depstrings);
+	list_display_linebreak(COLOR_WHITE_ALL, _("Optional Deps  :"), alpm_pkg_get_optdepends(pkg));
 	/* Only applicable if installed */
 	if(level > 0) {
-		list_display(_("Required By    :"), requiredby);
+		list_display(COLOR_WHITE_ALL, _("Required By    :"), requiredby);
 		FREELIST(requiredby);
 	}
-	list_display(_("Conflicts With :"), alpm_pkg_get_conflicts(pkg));
-	list_display(_("Replaces       :"), alpm_pkg_get_replaces(pkg));
+	list_display(COLOR_WHITE_ALL, _("Conflicts With :"), alpm_pkg_get_conflicts(pkg));
+	list_display(COLOR_WHITE_ALL, _("Replaces       :"), alpm_pkg_get_replaces(pkg));
 	if(level < 0) {
-		printf(_("Download Size  : %6.2f K\n"),
+		color_printf(COLOR_WHITE_COLON, _("Download Size  : %6.2f K\n"),
 			(float)alpm_pkg_get_size(pkg) / 1024.0);
 	}
 	if(level == 0) {
-		printf(_("Compressed Size: %6.2f K\n"),
+		color_printf(COLOR_WHITE_COLON, _("Compressed Size: %6.2f K\n"),
 			(float)alpm_pkg_get_size(pkg) / 1024.0);
 	}
 
-	printf(_("Installed Size : %6.2f K\n"),
+	color_printf(COLOR_WHITE_COLON, _("Installed Size : %6.2f K\n"),
 			(float)alpm_pkg_get_isize(pkg) / 1024.0);
-	string_display(_("Packager       :"), alpm_pkg_get_packager(pkg));
-	string_display(_("Architecture   :"), alpm_pkg_get_arch(pkg));
-	string_display(_("Build Date     :"), bdatestr);
+	string_display(COLOR_WHITE_ALL, _("Packager       :"), alpm_pkg_get_packager(pkg));
+	string_display(COLOR_WHITE_ALL, _("Architecture   :"), alpm_pkg_get_arch(pkg));
+	string_display(COLOR_WHITE_ALL, _("Build Date     :"), bdatestr);
 	if(level > 0) {
-		string_display(_("Install Date   :"), idatestr);
-		string_display(_("Install Reason :"), reason);
-	}
+		string_display(COLOR_WHITE_ALL, _("Install Date   :"), idatestr);
+		string_display(COLOR_WHITE_ALL, _("Install Reason :"), reason);	}
 	if(level >= 0) {
-		string_display(_("Install Script :"),
+		string_display(COLOR_WHITE_ALL, _("Install Script :"),
 				alpm_pkg_has_scriptlet(pkg) ?  _("Yes") : _("No"));
 	}
 
 	/* MD5 Sum for sync package */
 	if(level < 0) {
-		string_display(_("MD5 Sum        :"), alpm_pkg_get_md5sum(pkg));
+		string_display(COLOR_WHITE_ALL, _("MD5 Sum        :"), alpm_pkg_get_md5sum(pkg));
 	}
-	string_display(_("Description    :"), alpm_pkg_get_desc(pkg));
+	string_display(COLOR_WHITE_ALL, _("Description    :"), alpm_pkg_get_desc(pkg));
 
 	/* Print additional package info if info flag passed more than once */
 	if(level > 1) {
@@ -151,7 +150,7 @@
 	if(pkg == NULL) {
 		return;
 	}
-	string_display(_("Repository     :"), treename);
+	color_string_display(COLOR_WHITE_ALL, _("Repository     :"), COLOR_MAGENTA_ALL, treename);
 	dump_pkg_full(pkg, -1);
 }
 
@@ -161,7 +160,7 @@
 {
 	alpm_list_t *i;
 	const char *root = alpm_option_get_root();
-	printf(_("Backup Files:\n"));
+	color_printf(COLOR_WHITE_ALL, _("Backup Files:\n"));
 	if(alpm_pkg_get_backup(pkg)) {
 		/* package has backup files, so print them */
 		for(i = alpm_pkg_get_backup(pkg); i; i = alpm_list_next(i)) {
@@ -188,13 +187,13 @@
 
 				/* if checksums don't match, file has been modified */
 				if (strcmp(md5sum, ptr)) {
-					printf(_("MODIFIED\t%s\n"), path);
+					color_printf(COLOR_YELLOW_ALL, _("MODIFIED\t%s\n"), path);
 				} else {
-					printf(_("Not Modified\t%s\n"), path);
+					color_printf(COLOR_GREEN_ALL, _("Not Modified\t%s\n"), path);
 				}
 				free(md5sum);
 			} else {
-				printf(_("MISSING\t\t%s\n"), path);
+				color_printf(COLOR_RED_ALL, _("MISSING\t\t%s\n"), path);
 			}
 			free(str);
 		}
@@ -218,7 +217,8 @@
 	for(i = pkgfiles; i; i = alpm_list_next(i)) {
 		filestr = alpm_list_getdata(i);
 		if(!quiet){
-			fprintf(stdout, "%s %s%s\n", pkgname, root, filestr);
+			color_fprintf(stdout, COLOR_WHITE_ALL, "%s", pkgname);
+			fprintf(stdout, " %s%s\n", root, filestr);
 		} else {
 			fprintf(stdout, "%s%s\n", root, filestr);
 		}
diff -Naur pacman-3.3.3/src/pacman/pacman.c pacman-color-3.3.3/src/pacman/pacman.c
--- pacman-3.3.3/src/pacman/pacman.c	2009-09-30 03:38:36.000000000 +0200
+++ pacman-color-3.3.3/src/pacman/pacman.c	2009-11-11 17:38:37.000000000 +0100
@@ -156,11 +156,22 @@
  */
 static void version(void)
 {
-	printf("\n");
-	printf(" .--.                  Pacman v%s - libalpm v%s\n", PACKAGE_VERSION, alpm_version());
-	printf("/ _.-' .-.  .-.  .-.   Copyright (C) 2006-2009 Pacman Development Team\n");
-	printf("\\  '-. '-'  '-'  '-'   Copyright (C) 2002-2006 Judd Vinet\n");
-	printf(" '--'\n");
+	color_printf(COLOR_YELLOW_ALL, " .--. ");
+	printf("        ");
+	color_printf(COLOR_RED_ALL, " .---. ");
+	printf("  Pacman-color v%s - libalpm v%s\n", PACKAGE_VERSION, alpm_version());
+	color_printf(COLOR_YELLOW_ALL, "/ _.-'");
+	color_printf(COLOR_WHITE_ALL, " .-.  .-");
+	color_printf(COLOR_RED_ALL, "|O O  |");
+	printf("  Copyright (C) 2006-2009 Pacman Development Team\n");
+	color_printf(COLOR_YELLOW_ALL, "\\  '-.");
+	color_printf(COLOR_WHITE_ALL, " '-'  '-");
+	color_printf(COLOR_RED_ALL, "|~~~  |");
+	printf("  Copyright (C) 2002-2006 Judd Vinet\n");
+	color_printf(COLOR_YELLOW_ALL, " '--' ");
+	printf("        ");
+	color_printf(COLOR_RED_ALL, "|.-.-.|");
+	printf("  Colored by vogo <vogo(at)seznam(dot)cz>\n");
 	printf(_("                       This program may be freely redistributed under\n"
 	         "                       the terms of the GNU General Public License.\n"));
 	printf("\n");
@@ -971,6 +982,7 @@
 
 	/* init config data */
 	config = config_new();
+	parsecolorconfig();
 
 	/* disable progressbar if the output is redirected */
 	if(!isatty(1)) {
@@ -1028,17 +1040,17 @@
 
 	if(config->verbose > 0) {
 		alpm_list_t *i;
-		printf("Root      : %s\n", alpm_option_get_root());
-		printf("Conf File : %s\n", config->configfile);
-		printf("DB Path   : %s\n", alpm_option_get_dbpath());
-		printf("Cache Dirs: ");
+		string_display(COLOR_WHITE_ALL, "Root      :", alpm_option_get_root());
+		string_display(COLOR_WHITE_ALL, "Conf File :", config->configfile);
+		string_display(COLOR_WHITE_ALL, "DB Path   :", alpm_option_get_dbpath());
+		color_printf(COLOR_WHITE_ALL, "Cache Dirs: ");
 		for(i = alpm_option_get_cachedirs(); i; i = alpm_list_next(i)) {
 			printf("%s  ", (char*)alpm_list_getdata(i));
 		}
 		printf("\n");
-		printf("Lock File : %s\n", alpm_option_get_lockfile());
-		printf("Log File  : %s\n", alpm_option_get_logfile());
-		list_display("Targets   :", pm_targets);
+		string_display(COLOR_WHITE_ALL, "Lock File :", alpm_option_get_lockfile());
+		string_display(COLOR_WHITE_ALL, "Log File  :", alpm_option_get_logfile());
+		list_display(COLOR_WHITE_ALL, "Targets   :", pm_targets);
 	}
 
 	/* Opening local database */
diff -Naur pacman-3.3.3/src/pacman/query.c pacman-color-3.3.3/src/pacman/query.c
--- pacman-3.3.3/src/pacman/query.c	2009-09-30 03:38:22.000000000 +0200
+++ pacman-color-3.3.3/src/pacman/query.c	2009-11-11 17:38:37.000000000 +0100
@@ -166,7 +166,9 @@
 		pmpkg_t *pkg = alpm_list_getdata(i);
 
 		if (!config->quiet) {
-			printf("local/%s %s", alpm_pkg_get_name(pkg), alpm_pkg_get_version(pkg));
+			color_printf(COLOR_MAGENTA_ALL, "local/");
+			color_printf(COLOR_WHITE_ALL, "%s ", alpm_pkg_get_name(pkg));
+			color_printf(COLOR_GREEN_ALL, "%s", alpm_pkg_get_version(pkg));
 		} else {
 			printf("%s", alpm_pkg_get_name(pkg));
 		}
@@ -183,16 +185,11 @@
 		if (!config->quiet) {
 			if((grp = alpm_pkg_get_groups(pkg)) != NULL) {
 				alpm_list_t *k;
-				printf(" (");
+				color_printf(COLOR_BLUE_ALL, " (");
 				for(k = grp; k; k = alpm_list_next(k)) {
 					const char *group = alpm_list_getdata(k);
-					printf("%s", group);
-					if(alpm_list_next(k)) {
-						/* only print a spacer if there are more groups */
-						printf(" ");
-					}
+					color_printf(COLOR_BLUE_ALL, "%s%s", group, (alpm_list_next(k) ? " " : ")"));
 				}
-				printf(")");
 			}
 
 			/* we need a newline and initial indent first */
@@ -224,7 +221,8 @@
 			packages = alpm_grp_get_pkgs(grp);
 
 			for(p = packages; p; p = alpm_list_next(p)) {
-				printf("%s %s\n", grpname, alpm_pkg_get_name(alpm_list_getdata(p)));
+				color_printf(COLOR_BLUE_ALL, "%s ", grpname);
+				color_printf(COLOR_WHITE_ALL, "%s\n", alpm_pkg_get_name(alpm_list_getdata(p)));
 			}
 		}
 	} else {
@@ -236,8 +234,8 @@
 				const alpm_list_t *p, *packages = alpm_grp_get_pkgs(grp);
 				for(p = packages; p; p = alpm_list_next(p)) {
 					if(!config->quiet) {
-						printf("%s %s\n", grpname,
-								alpm_pkg_get_name(alpm_list_getdata(p)));
+						color_printf(COLOR_BLUE_ALL, "%s ", grpname);
+						color_printf(COLOR_WHITE_ALL, "%s\n", alpm_pkg_get_name(alpm_list_getdata(p)));
 					} else {
 						printf("%s\n", alpm_pkg_get_name(alpm_list_getdata(p)));
 					}
@@ -383,7 +381,8 @@
 	if(!config->op_q_info && !config->op_q_list
 			&& !config->op_q_changelog && !config->op_q_check) {
 		if (!config->quiet) {
-			printf("%s %s\n", alpm_pkg_get_name(pkg), alpm_pkg_get_version(pkg));
+			color_printf(COLOR_WHITE_ALL, "%s ", alpm_pkg_get_name(pkg));
+			color_printf(COLOR_GREEN_ALL, "%s\n", alpm_pkg_get_version(pkg));
 		} else {
 			printf("%s\n", alpm_pkg_get_name(pkg));
 		}
diff -Naur pacman-3.3.3/src/pacman/remove.c pacman-color-3.3.3/src/pacman/remove.c
--- pacman-3.3.3/src/pacman/remove.c	2009-09-30 03:38:36.000000000 +0200
+++ pacman-color-3.3.3/src/pacman/remove.c	2009-11-11 17:38:37.000000000 +0100
@@ -73,12 +73,12 @@
 						pmpkg_t *pkg = alpm_list_getdata(p);
 						pkgnames = alpm_list_add(pkgnames, (void *)alpm_pkg_get_name(pkg));
 					}
-					printf(_(":: group %s:\n"), targ);
-					list_display("   ", pkgnames);
-					int all = yesno(_("    Remove whole content?"));
-					for(p = pkgnames; p; p = alpm_list_next(p)) {
+					color_printf(COLOR_DOUBLECOLON, _(":: group %s:\n"), targ);
+					list_display(NULL, "   ", pkgnames);
+					int all = yesno(NULL, _("    Remove whole content?"));
+ 					for(p = pkgnames; p; p = alpm_list_next(p)) {
 						char *pkgn = alpm_list_getdata(p);
-						if(all || yesno(_(":: Remove %s from group %s?"), pkgn, targ)) {
+						if(all || yesno(COLOR_DOUBLECOLON, _(":: Remove %s from group %s?"), pkgn, targ)) {
 							if(alpm_trans_addtarget(pkgn) == -1) {
 								pm_fprintf(stderr, PM_LOG_ERROR, "'%s': %s\n", targ,
 								           alpm_strerrorlast());
@@ -108,7 +108,7 @@
 					pmdepmissing_t *miss = alpm_list_getdata(i);
 					pmdepend_t *dep = alpm_miss_get_dep(miss);
 					char *depstring = alpm_dep_compute_string(dep);
-					printf(_(":: %s: requires %s\n"), alpm_miss_get_target(miss),
+					color_printf(COLOR_DOUBLECOLON, _(":: %s: requires %s\n"), alpm_miss_get_target(miss),
 							depstring);
 					free(depstring);
 				}
@@ -131,7 +131,7 @@
 			holdpkg = 1;
 		}
 	}
-	if(holdpkg && (noyes(_("HoldPkg was found in target list. Do you want to continue?")) == 0)) {
+	if(holdpkg && (noyes(NULL, _("HoldPkg was found in target list. Do you want to continue?")) == 0)) {
 		retval = 1;
 		goto cleanup;
 	}
@@ -146,7 +146,7 @@
 		printf("\n");
 
 		/* get confirmation */
-		if(yesno(_("Do you want to remove these packages?")) == 0) {
+		if(yesno(NULL, _("Do you want to remove these packages?")) == 0) {
 			retval = 1;
 			goto cleanup;
 		}
diff -Naur pacman-3.3.3/src/pacman/sync.c pacman-color-3.3.3/src/pacman/sync.c
--- pacman-3.3.3/src/pacman/sync.c	2009-09-30 03:38:36.000000000 +0200
+++ pacman-color-3.3.3/src/pacman/sync.c	2009-11-11 17:38:37.000000000 +0100
@@ -86,7 +86,7 @@
 		/* We have a directory that doesn't match any syncdb.
 		 * Ask the user if he wants to remove it. */
 		if(!found) {
-			if(!yesno(_("Do you want to remove %s?"), path)) {
+			if(!yesno(NULL, _("Do you want to remove %s?"), path)) {
 				continue;
 			}
 
@@ -105,8 +105,8 @@
 	const char *dbpath = alpm_option_get_dbpath();
 	char newdbpath[PATH_MAX];
 
-	printf(_("Database directory: %s\n"), dbpath);
-	if(!yesno(_("Do you want to remove unused repositories?"))) {
+	color_printf(COLOR_WHITE_COLON, _("Database directory: %s\n"), dbpath);
+	if(!yesno(NULL, _("Do you want to remove unused repositories?"))) {
 		return(0);
 	}
 	/* The sync dbs were previously put in dbpath/, but are now in dbpath/sync/,
@@ -133,15 +133,15 @@
 		struct dirent *ent;
 		/* Open up each package and see if it should be deleted,
 		 * depending on the clean method used */
-		printf(_("Cache directory: %s\n"), cachedir);
+		color_printf(COLOR_WHITE_COLON, _("Cache directory: %s\n"), cachedir);
 		switch(config->cleanmethod) {
 			case PM_CLEAN_KEEPINST:
-				if(!yesno(_("Do you want to remove uninstalled packages from cache?"))) {
+				if(!yesno(NULL, _("Do you want to remove uninstalled packages from cache?"))) {
 					return(0);
 				}
 				break;
 			case PM_CLEAN_KEEPCUR:
-				if(!yesno(_("Do you want to remove outdated packages from cache?"))) {
+				if(!yesno(NULL, _("Do you want to remove outdated packages from cache?"))) {
 					return(0);
 				}
 				break;
@@ -176,7 +176,7 @@
 			 * files here that aren't valid packages. we also don't need a full
 			 * load of the package, just the metadata. */
 			if(alpm_pkg_load(path, 0, &localpkg) != 0 || localpkg == NULL) {
-				if(yesno(_("File %s does not seem to be a valid package, remove it?"), path)) {
+				if(yesno(NULL, _("File %s does not seem to be a valid package, remove it?"), path)) {
 					unlink(path);
 				}
 				continue;
@@ -217,8 +217,8 @@
 		}
 	} else {
 		/* full cleanup */
-		printf(_("Cache directory: %s\n"), cachedir);
-		if(!noyes(_("Do you want to remove ALL files from cache?"))) {
+		color_printf(COLOR_WHITE_COLON, _("Cache directory: %s\n"), cachedir);
+		if(!noyes(NULL, _("Do you want to remove ALL files from cache?"))) {
 			return(0);
 		}
 		printf(_("removing all files from cache...\n"));
@@ -301,8 +301,9 @@
 			pmpkg_t *pkg = alpm_list_getdata(j);
 
 			if (!config->quiet) {
-				printf("%s/%s %s", alpm_db_get_name(db), alpm_pkg_get_name(pkg),
-							 alpm_pkg_get_version(pkg));
+				color_printf(COLOR_MAGENTA_ALL, "%s/", alpm_db_get_name(db));
+				color_printf(COLOR_WHITE_ALL, "%s ", alpm_pkg_get_name(pkg));
+				color_printf(COLOR_GREEN_ALL, "%s", alpm_pkg_get_version(pkg));
 			} else {
 				printf("%s", alpm_pkg_get_name(pkg));
 			}
@@ -318,16 +319,11 @@
 			if (!config->quiet) {
 				if((grp = alpm_pkg_get_groups(pkg)) != NULL) {
 					alpm_list_t *k;
-					printf(" (");
+					color_printf(COLOR_BLUE_ALL, " (");
 					for(k = grp; k; k = alpm_list_next(k)) {
 						const char *group = alpm_list_getdata(k);
-						printf("%s", group);
-						if(alpm_list_next(k)) {
-							/* only print a spacer if there are more groups */
-							printf(" ");
-						}
+						color_printf(COLOR_BLUE_ALL, "%s%s", group, (alpm_list_next(k) ? " " : ")"));
 					}
-					printf(")");
 				}
 
 				/* we need a newline and initial indent first */
@@ -360,8 +356,8 @@
 					/* get names of packages in group */
 					for(k = alpm_grp_get_pkgs(grp); k; k = alpm_list_next(k)) {
 						if(!config->quiet) {
-							printf("%s %s\n", grpname,
-									alpm_pkg_get_name(alpm_list_getdata(k)));
+							color_printf(COLOR_BLUE_ALL, "%s ", grpname);
+							color_printf(COLOR_WHITE_ALL, "%s\n", alpm_pkg_get_name(alpm_list_getdata(k)));
 						} else {
 							printf("%s\n", alpm_pkg_get_name(alpm_list_getdata(k)));
 						}
@@ -379,8 +375,8 @@
 
 				if(level > 1) {
 					for(k = alpm_grp_get_pkgs(grp); k; k = alpm_list_next(k)) {
-						printf("%s %s\n", grpname,
-								alpm_pkg_get_name(alpm_list_getdata(k)));
+						color_printf(COLOR_BLUE_ALL, "%s ", grpname);
+						color_printf(COLOR_WHITE_ALL, "%s\n", alpm_pkg_get_name(alpm_list_getdata(k)));
 					}
 				} else {
 					/* print grp names only, no package names */
@@ -515,8 +511,9 @@
 		for(j = alpm_db_get_pkgcache(db); j; j = alpm_list_next(j)) {
 			pmpkg_t *pkg = alpm_list_getdata(j);
 			if (!config->quiet) {
-				printf("%s %s %s\n", alpm_db_get_name(db), alpm_pkg_get_name(pkg),
-							 alpm_pkg_get_version(pkg));
+				color_printf(COLOR_MAGENTA_ALL, "%s ", alpm_db_get_name(db));
+				color_printf(COLOR_WHITE_ALL, "%s ", alpm_pkg_get_name(pkg));
+				color_printf(COLOR_GREEN_ALL, "%s\n", alpm_pkg_get_version(pkg));
 			} else {
 				printf("%s\n", alpm_pkg_get_name(pkg));
 			}
@@ -561,7 +558,7 @@
 	}
 
 	if(config->op_s_upgrade) {
-		printf(_(":: Starting full system upgrade...\n"));
+		color_printf(COLOR_DOUBLECOLON, _(":: Starting full system upgrade...\n"));
 		alpm_logaction("starting full system upgrade\n");
 		if(alpm_trans_sysupgrade(config->op_s_upgrade >= 2) == -1) {
 			pm_fprintf(stderr, PM_LOG_ERROR, "%s\n", alpm_strerrorlast());
@@ -599,7 +596,7 @@
 						alpm_list_t *k, *pkgnames = NULL;
 
 						found++;
-						printf(_(":: group %s (including ignored packages):\n"), targ);
+						color_printf(COLOR_DOUBLECOLON, _(":: group %s (including ignored packages):\n"), targ);
 						/* remove dupe entries in case a package exists in multiple repos */
 						alpm_list_t *grppkgs = alpm_grp_get_pkgs(grp);
 						alpm_list_t *pkgs = alpm_list_remove_dupes(grppkgs);
@@ -607,15 +604,15 @@
 							pkgnames = alpm_list_add(pkgnames,
 									(char*)alpm_pkg_get_name(k->data));
 						}
-						list_display("   ", pkgnames);
-						if(yesno(_(":: Install whole content?"))) {
+						list_display(NULL, "   ", pkgnames);
+						if(yesno(COLOR_DOUBLECOLON, _(":: Install whole content?"))) {
 							for(k = pkgnames; k; k = alpm_list_next(k)) {
 								targets = alpm_list_add(targets, strdup(alpm_list_getdata(k)));
 							}
 						} else {
 							for(k = pkgnames; k; k = alpm_list_next(k)) {
 								char *pkgname = alpm_list_getdata(k);
-								if(yesno(_(":: Install %s from group %s?"), pkgname, targ)) {
+								if(yesno(COLOR_DOUBLECOLON, _(":: Install %s from group %s?"), pkgname, targ)) {
 									targets = alpm_list_add(targets, strdup(pkgname));
 								}
 							}
@@ -644,7 +641,7 @@
 					pmdepmissing_t *miss = alpm_list_getdata(i);
 					pmdepend_t *dep = alpm_miss_get_dep(miss);
 					char *depstring = alpm_dep_compute_string(dep);
-					printf(_(":: %s: requires %s\n"), alpm_miss_get_target(miss),
+					color_printf(COLOR_DOUBLECOLON, _(":: %s: requires %s\n"), alpm_miss_get_target(miss),
 							depstring);
 					free(depstring);
 				}
@@ -652,7 +649,7 @@
 			case PM_ERR_CONFLICTING_DEPS:
 			  for(i = data; i; i = alpm_list_next(i)) {
 					pmconflict_t *conflict = alpm_list_getdata(i);
-					printf(_(":: %s: conflicts with %s\n"),
+					color_printf(COLOR_DOUBLECOLON, _(":: %s: conflicts with %s\n"),
 							alpm_conflict_get_package1(conflict), alpm_conflict_get_package2(conflict));
 				}
 				break;
@@ -696,9 +693,9 @@
 
 	int confirm;
 	if(config->op_s_downloadonly) {
-		confirm = yesno(_("Proceed with download?"));
+		confirm = yesno(NULL, _("Proceed with download?"));
 	} else {
-		confirm = yesno(_("Proceed with installation?"));
+		confirm = yesno(NULL, _("Proceed with installation?"));
 	}
 	if(!confirm) {
 		goto cleanup;
@@ -720,7 +717,7 @@
 									alpm_fileconflict_get_ctarget(conflict));
 							break;
 						case PM_FILECONFLICT_FILESYSTEM:
-							printf(_("%s: %s exists in filesystem\n"),
+							color_printf(COLOR_WHITE_COLON, _("%s: %s exists in filesystem\n"),
 									alpm_fileconflict_get_target(conflict),
 									alpm_fileconflict_get_file(conflict));
 							break;
@@ -738,7 +735,7 @@
 				break;
 		}
 		/* TODO: stderr? */
-		printf(_("Errors occurred, no packages were upgraded.\n"));
+		color_printf(COLOR_RED_ALL, _("Errors occurred, no packages were upgraded.\n"));
 		retval = 1;
 		goto cleanup;
 	}
@@ -792,7 +789,7 @@
 
 	if(config->op_s_sync) {
 		/* grab a fresh package list */
-		printf(_(":: Synchronizing package databases...\n"));
+		color_printf(COLOR_DOUBLECOLON, _(":: Synchronizing package databases...\n"));
 		alpm_logaction("synchronizing package lists\n");
 		if(!sync_synctree(config->op_s_sync, sync_dbs)) {
 			return(1);
@@ -837,13 +834,13 @@
 		/* check for newer versions of packages to be upgraded first */
 		alpm_list_t *packages = syncfirst();
 		if(packages) {
-			/* Do not ask user if all the -S targets are SyncFirst packages, see FS#15810 */
+		  /* Do not ask user if all the -S targets are SyncFirst packages, see FS#15810 */
 			alpm_list_t *tmp = NULL;
 			if(config->op_s_upgrade || (tmp = alpm_list_diff(targets, packages, (alpm_list_fn_cmp)strcmp))) {
 				alpm_list_free(tmp);
-				printf(_(":: The following packages should be upgraded first :\n"));
-				list_display("   ", packages);
-				if(yesno(_(":: Do you want to cancel the current operation\n"
+				color_printf(COLOR_DOUBLECOLON, _(":: The following packages should be upgraded first :\n"));
+				list_display(NULL, "   ", packages);
+				if(yesno(COLOR_DOUBLECOLON2, _(":: Do you want to cancel the current operation\n"
 								":: and upgrade these packages now?"))) {
 					FREELIST(targs);
 					targs = packages;
diff -Naur pacman-3.3.3/src/pacman/upgrade.c pacman-color-3.3.3/src/pacman/upgrade.c
--- pacman-3.3.3/src/pacman/upgrade.c	2009-09-30 03:38:36.000000000 +0200
+++ pacman-color-3.3.3/src/pacman/upgrade.c	2009-11-11 17:38:37.000000000 +0100
@@ -96,7 +96,7 @@
 					/* TODO indicate if the error was a virtual package or not:
 					 *		:: %s: requires %s, provided by %s
 					 */
-					printf(_(":: %s: requires %s\n"), alpm_miss_get_target(miss),
+					color_printf(COLOR_DOUBLECOLON, _(":: %s: requires %s\n"), alpm_miss_get_target(miss),
 							depstring);
 					free(depstring);
 				}
@@ -104,7 +104,7 @@
 			case PM_ERR_CONFLICTING_DEPS:
 				for(i = data; i; i = alpm_list_next(i)) {
 					pmconflict_t *conflict = alpm_list_getdata(i);
-					printf(_(":: %s: conflicts with %s\n"),
+					color_printf(COLOR_DOUBLECOLON, _(":: %s: conflicts with %s\n"),
 						alpm_conflict_get_package1(conflict), alpm_conflict_get_package2(conflict));
 				}
 				break;
@@ -119,13 +119,13 @@
 							        alpm_fileconflict_get_ctarget(conflict));
 						break;
 						case PM_FILECONFLICT_FILESYSTEM:
-							printf(_("%s: %s exists in filesystem\n"),
+							color_printf(COLOR_WHITE_COLON, _("%s: %s exists in filesystem\n"),
 							        alpm_fileconflict_get_target(conflict),
 							        alpm_fileconflict_get_file(conflict));
 						break;
 					}
 				}
-				printf(_("\nerrors occurred, no packages were upgraded.\n"));
+				color_printf(COLOR_RED_ALL, _("\nerrors occurred, no packages were upgraded.\n"));
 				break;
 			default:
 				break;
diff -Naur pacman-3.3.3/src/pacman/util.c pacman-color-3.3.3/src/pacman/util.c
--- pacman-3.3.3/src/pacman/util.c	2009-10-28 03:10:04.000000000 +0100
+++ pacman-color-3.3.3/src/pacman/util.c	2009-11-11 17:38:37.000000000 +0100
@@ -44,6 +44,20 @@
 #include "conf.h"
 #include "callback.h"
 
+#define COLOR_LEN 8
+
+typedef struct __colortab_t {
+	char red[COLOR_LEN + 1];
+	char green[COLOR_LEN + 1];
+	char yellow[COLOR_LEN + 1];
+	char blue[COLOR_LEN + 1];
+	char magenta[COLOR_LEN + 1];
+	char cyan[COLOR_LEN + 1];
+	char white[COLOR_LEN + 1];
+	char none[COLOR_LEN + 1];
+} colortab_t;
+
+static colortab_t colortab;
 
 int trans_init(pmtranstype_t type, pmtransflag_t flags)
 {
@@ -441,14 +455,14 @@
 	return(len);
 }
 
-void string_display(const char *title, const char *string)
+void string_display(const colordata_t *colors_title, const char *title, const char *string)
 {
 	int len = 0;
 
 	if(title) {
 		/* compute the length of title + a space */
 		len = string_length(title) + 1;
-		printf("%s ", title);
+		color_printf(colors_title, "%s ", title);
 	}
 	if(string == NULL || string[0] == '\0') {
 		printf(_("None"));
@@ -458,14 +472,14 @@
 	printf("\n");
 }
 
-void list_display(const char *title, const alpm_list_t *list)
+void list_display(const colordata_t *colors_title, const char *title, const alpm_list_t *list)
 {
 	const alpm_list_t *i;
 	int cols, len = 0;
 
 	if(title) {
 		len = string_length(title) + 1;
-		printf("%s ", title);
+		color_printf(colors_title, "%s ", title);
 	}
 
 	if(!list) {
@@ -492,14 +506,14 @@
 	}
 }
 
-void list_display_linebreak(const char *title, const alpm_list_t *list)
+void list_display_linebreak(const colordata_t *colors_title, const char *title, const alpm_list_t *list)
 {
 	const alpm_list_t *i;
 	int len = 0;
 
 	if(title) {
 		len = string_length(title) + 1;
-		printf("%s ", title);
+		color_printf(colors_title, "%s ", title);
 	}
 
 	if(!list) {
@@ -559,19 +573,20 @@
 
 	if(install) {
 		asprintf(&str, _("Targets (%d):"), alpm_list_count(targets));
-		list_display(str, targets);
+		list_display(COLOR_YELLOW_ALL, str, targets);
 		free(str);
 		printf("\n");
 
-		printf(_("Total Download Size:    %.2f MB\n"), mbdlsize);
-		printf(_("Total Installed Size:   %.2f MB\n"), mbisize);
+		color_printf(COLOR_WHITE_COLON, _("Total Download Size:    %.2f MB\n"), mbdlsize);
+		color_printf(COLOR_WHITE_COLON, _("Total Installed Size:   %.2f MB\n"), mbisize);
+
 	} else {
 		asprintf(&str, _("Remove (%d):"), alpm_list_count(targets));
-		list_display(str, targets);
+		list_display(COLOR_RED_ALL, str, targets);
 		free(str);
 		printf("\n");
 
-		printf(_("Total Removed Size:   %.2f MB\n"), mbisize);
+		color_printf(COLOR_WHITE_COLON, _("Total Removed Size:   %.2f MB\n"), mbisize);
 	}
 
 	FREELIST(targets);
@@ -622,7 +637,7 @@
 	alpm_list_t *optdeps = alpm_list_diff(new,old,str_cmp);
 	if(optdeps) {
 		printf(_("New optional dependencies for %s\n"), alpm_pkg_get_name(newpkg));
-		list_display_linebreak("   ", optdeps);
+		list_display_linebreak(NULL, "   ", optdeps);
 	}
 	alpm_list_free(optdeps);
 }
@@ -632,12 +647,12 @@
 	alpm_list_t *optdeps = alpm_pkg_get_optdepends(pkg);
 	if(optdeps) {
 		printf(_("Optional dependencies for %s\n"), alpm_pkg_get_name(pkg));
-		list_display_linebreak("   ", optdeps);
+		list_display_linebreak(NULL, "   ", optdeps);
 	}
 }
 
 /* presents a prompt and gets a Y/N answer */
-static int question(short preset, char *fmt, va_list args)
+static int question(const colordata_t *colors, short preset, char *fmt, va_list args)
 {
 	char response[32];
 	FILE *stream;
@@ -649,7 +664,7 @@
 		stream = stderr;
 	}
 
-	vfprintf(stream, fmt, args);
+	color_vfprintf(stream, colors, fmt, args);
 
 	if(preset) {
 		fprintf(stream, " %s ", _("[Y/n]"));
@@ -677,25 +692,25 @@
 	return(0);
 }
 
-int yesno(char *fmt, ...)
+int yesno(const colordata_t *colors, char *fmt, ...)
 {
 	int ret;
 	va_list args;
 
 	va_start(args, fmt);
-	ret = question(1, fmt, args);
+	ret = question(colors, 1, fmt, args);
 	va_end(args);
 
 	return(ret);
 }
 
-int noyes(char *fmt, ...)
+int noyes(const colordata_t *colors, char *fmt, ...)
 {
 	int ret;
 	va_list args;
 
 	va_start(args, fmt);
-	ret = question(0, fmt, args);
+	ret = question(colors, 0, fmt, args);
 	va_end(args);
 
 	return(ret);
@@ -741,21 +756,40 @@
 	ret = vasprintf(&msg, format, args);
 
 	/* print a prefix to the message */
-	switch(level) {
-		case PM_LOG_DEBUG:
-			asprintf(string, "debug: %s", msg);
-			break;
-		case PM_LOG_ERROR:
-			asprintf(string, _("error: %s"), msg);
-			break;
-		case PM_LOG_WARNING:
-			asprintf(string, _("warning: %s"), msg);
-			break;
-		case PM_LOG_FUNCTION:
-			asprintf(string, _("function: %s"), msg);
-			break;
-		default:
-			break;
+	if(isatty(fileno(stdout))) {
+		switch(level) {
+			case PM_LOG_DEBUG:
+				asprintf(string, "debug: %s", msg);
+				break;
+			case PM_LOG_ERROR:
+				asprintf(string, "%s%s%s%s", colortab.red, _("error: "), colortab.none, msg);
+				break;
+			case PM_LOG_WARNING:
+				asprintf(string, "%s%s%s%s", colortab.yellow, _("warning: "), colortab.none, msg);
+				break;
+			case PM_LOG_FUNCTION:
+				asprintf(string, _("function: %s"), msg);
+				break;
+			default:
+				break;
+		}
+	} else {
+		switch(level) {
+			case PM_LOG_DEBUG:
+				asprintf(string, "debug: %s", msg);
+				break;
+			case PM_LOG_ERROR:
+				asprintf(string, _("error: %s"), msg);
+				break;
+			case PM_LOG_WARNING:
+				asprintf(string, _("warning: %s"), msg);
+				break;
+			case PM_LOG_FUNCTION:
+				asprintf(string, _("function: %s"), msg);
+				break;
+			default:
+				break;
+		}
 	}
 	free(msg);
 
@@ -793,10 +827,10 @@
 			fprintf(stream, "debug: ");
 			break;
 		case PM_LOG_ERROR:
-			fprintf(stream, _("error: "));
+			color_fprintf(stream, COLOR_RED_ALL, _("error: "));
 			break;
 		case PM_LOG_WARNING:
-			fprintf(stream, _("warning: "));
+			color_fprintf(stream, COLOR_YELLOW_ALL, _("warning: "));
 			break;
 		case PM_LOG_FUNCTION:
 		  /* TODO we should increase the indent level when this occurs so we can see
@@ -834,4 +868,310 @@
 }
 #endif
 
+/* pacman-color */
+
+int _set_color_sequence(const char* name, char* dest)
+{
+	int ret = 0;
+
+	if(strcmp(name, "black") == 0) {
+		strncpy(dest, "\033[0;30m", COLOR_LEN);
+	} else if(strcmp(name, "red") == 0) {
+		strncpy(dest, "\033[0;31m", COLOR_LEN);
+	} else if(strcmp(name, "green") == 0) {
+		strncpy(dest, "\033[0;32m", COLOR_LEN);
+	} else if(strcmp(name, "yellow") == 0) {
+		strncpy(dest, "\033[0;33m", COLOR_LEN);
+	} else if(strcmp(name, "blue") == 0) {
+		strncpy(dest, "\033[0;34m", COLOR_LEN);
+	} else if(strcmp(name, "magenta") == 0) {
+		strncpy(dest, "\033[0;35m", COLOR_LEN);
+	} else if(strcmp(name, "cyan") == 0) {
+		strncpy(dest, "\033[0;36m", COLOR_LEN);
+	} else if(strcmp(name, "white") == 0) {
+		strncpy(dest, "\033[0;37m", COLOR_LEN);
+	} else if(strcmp(name, "gray") == 0) {
+		strncpy(dest, "\033[1;30m", COLOR_LEN);
+	} else if(strcmp(name, "intensive red") == 0) {
+		strncpy(dest, "\033[1;31m", COLOR_LEN);
+	} else if(strcmp(name, "intensive green") == 0) {
+		strncpy(dest, "\033[1;32m", COLOR_LEN);
+	} else if(strcmp(name, "intensive yellow") == 0) {
+		strncpy(dest, "\033[1;33m", COLOR_LEN);
+	} else if(strcmp(name, "intensive blue") == 0) {
+		strncpy(dest, "\033[1;34m", COLOR_LEN);
+	} else if(strcmp(name, "intensive magenta") == 0) {
+		strncpy(dest, "\033[1;35m", COLOR_LEN);
+	} else if(strcmp(name, "intensive cyan") == 0) {
+		strncpy(dest, "\033[1;36m", COLOR_LEN);
+	} else if(strcmp(name, "intensive white") == 0) {
+		strncpy(dest, "\033[1;37m", COLOR_LEN);
+	} else if(strcmp(name, "intensive foreground") == 0) {
+		strncpy(dest, "\033[m\033[1m", COLOR_LEN);
+	} else if(strcmp(name, "none") == 0) {
+		strncpy(dest, "\033[m", COLOR_LEN);
+	} else {
+		ret = 1;
+	}
+	dest[COLOR_LEN] = '\0';
+	return(ret);
+}
+
+void _insert_color(FILE* stream, color_t color)
+{
+	switch(color) {
+		case COLOR_RED:
+			fprintf(stream, colortab.red);
+			break;
+		case COLOR_GREEN:
+			fprintf(stream, colortab.green);
+			break;
+		case COLOR_YELLOW:
+			fprintf(stream, colortab.yellow);
+			break;
+		case COLOR_BLUE:
+			fprintf(stream, colortab.blue);
+			break;
+		case COLOR_MAGENTA:
+			fprintf(stream, colortab.magenta);
+			break;
+		case COLOR_CYAN:
+			fprintf(stream, colortab.cyan);
+			break;
+		case COLOR_WHITE:
+			fprintf(stream, colortab.white);
+			break;
+		case COLOR_NONE:
+			fprintf(stream, colortab.none);
+			break;
+		default:;
+	}
+}
+
+int _parsecolorconfig(colortab_t* colortab, char* file)
+{
+	_set_color_sequence("intensive red", colortab->red);
+	_set_color_sequence("intensive green", colortab->green);
+	_set_color_sequence("intensive yellow", colortab->yellow);
+	_set_color_sequence("intensive blue", colortab->blue);
+	_set_color_sequence("intensive magenta", colortab->magenta);
+	_set_color_sequence("intensive cyan", colortab->cyan);
+	_set_color_sequence("intensive foreground", colortab->white);
+	_set_color_sequence("none", colortab->none);
+
+	FILE* fp = NULL;
+	int linenum = 0;
+	char line[PATH_MAX+1];
+	char* ptr;
+
+	fp = fopen(file, "r");
+	if(fp == NULL) {
+		pm_printf(PM_LOG_ERROR, _("config file %s could not be read.\n"), file);
+		return 1;
+	}
+	while(fgets(line, PATH_MAX, fp)) {
+		linenum++;
+		strtrim(line);
+
+		if(strlen(line) == 0 || line[0] == '#') {
+			continue;
+		}
+		if((ptr = strchr(line, '#'))) {
+			*ptr = '\0';
+		}
+
+		char* key = line;
+		ptr = line;
+		strsep(&ptr, "=");
+		strtrim(key);
+		strtrim(ptr);
+
+		if(key == NULL) {
+			pm_printf(PM_LOG_ERROR, _("config file %s, line %d: syntax error in config file- missing key.\n"),
+					file, linenum);
+			return 1;
+		}
+		if(strcmp(key, "Red") == 0) {
+			if(_set_color_sequence(ptr, colortab->red)) {
+				pm_printf(PM_LOG_ERROR, _("config file %s, line %d: color '%s' not recognized.\n"),
+							file, linenum, ptr);
+			}
+		} else if(strcmp(key, "Green") == 0) {
+			if(_set_color_sequence(ptr, colortab->green)) {
+				pm_printf(PM_LOG_ERROR, _("config file %s, line %d: color '%s' not recognized.\n"),
+							file, linenum, ptr);
+			}
+		} else if(strcmp(key, "Yellow") == 0) {
+			if(_set_color_sequence(ptr, colortab->yellow)) {
+				pm_printf(PM_LOG_ERROR, _("config file %s, line %d: color '%s' not recognized.\n"),
+							file, linenum, ptr);
+			}
+		} else if(strcmp(key, "Blue") == 0) {
+			if(_set_color_sequence(ptr, colortab->blue)) {
+				pm_printf(PM_LOG_ERROR, _("config file %s, line %d: color '%s' not recognized.\n"),
+							file, linenum, ptr);
+			}
+		} else if(strcmp(key, "Magenta") == 0) {
+			if(_set_color_sequence(ptr, colortab->magenta)) {
+				pm_printf(PM_LOG_ERROR, _("config file %s, line %d: color '%s' not recognized.\n"),
+							file, linenum, ptr);
+			}
+		} else if(strcmp(key, "Cyan") == 0) {
+			if(_set_color_sequence(ptr, colortab->cyan)) {
+				pm_printf(PM_LOG_ERROR, _("config file %s, line %d: color '%s' not recognized.\n"),
+							file, linenum, ptr);
+			}
+		} else if(strcmp(key, "White") == 0) {
+			if(_set_color_sequence(ptr, colortab->white)) {
+				pm_printf(PM_LOG_ERROR, _("config file %s, line %d: color '%s' not recognized.\n"),
+							file, linenum, ptr);
+			}
+		} else {
+			pm_printf(PM_LOG_ERROR, _("config file %s, line %d: directive '%s' not recognized.\n"),
+					file, linenum, key);
+			return(1);
+		}
+	}
+	return(0);
+}
+
+int parsecolorconfig()
+{
+	return(_parsecolorconfig(&colortab, "/etc/pacman.d/color.conf"));
+}
+
+int color_vfprintf(FILE* stream, const colordata_t* colors, const char* format, va_list args)
+{
+	int ret = 0;
+
+	if(isatty(fileno(stream)) && colors) {
+		char* msg = NULL;
+		ret = vasprintf(&msg, format, args);
+		if(msg == NULL) {
+			return(ret);
+		}
+
+		const colordata_t* colorpos = colors;
+		color_t colorlast = COLOR_NONE;
+		int len = strlen(msg) + 1;
+		wchar_t* wcstr = calloc(len, sizeof(wchar_t));
+		len = mbstowcs(wcstr, msg, len);
+		free(msg);
+		const wchar_t *strpos = wcstr;
+		
+		while(*strpos) {
+			if(colorpos->color != COLOR_END &&
+				((colorpos->separator == SEP_ANY) ||
+				 (colorpos->separator == SEP_LINE && *strpos == L'\n') ||
+				 (colorpos->separator == SEP_COLON && (*strpos == L':' || *strpos == L'：')))) {
+				_insert_color(stream, colorpos->color);
+				colorlast = colorpos->color;
+				colorpos++;
+			}
+			fprintf(stream, "%lc", (wint_t)*strpos);
+			strpos++;
+		}
+		free(wcstr);
+
+		if(colorlast != COLOR_NONE) {
+			_insert_color(stream, COLOR_NONE);
+		}
+	} else {
+		ret = vfprintf(stream, format, args);
+	}
+	return(ret);
+}
+
+int color_fprintf(FILE* stream, const colordata_t* colors, const char* format, ...)
+{
+	int ret;
+	va_list args;
+	va_start(args, format);
+	ret = color_vfprintf(stream, colors, format, args);
+	va_end(args);
+	return(ret);
+}
+
+int color_printf(const colordata_t* colors, const char* format, ...)
+{
+	int ret;
+	va_list args;
+	va_start(args, format);
+	ret = color_vfprintf(stdout, colors, format, args);
+	va_end(args);
+	return(ret);
+}
+
+void color_string_display(const colordata_t* colors_title, const char* title, const colordata_t* colors_string, const char* string)
+{
+	if(title) {
+		color_printf(colors_title, "%s ", title);
+	}
+	if(string == NULL || string[0] == '\0') {
+		printf(_("None"));
+	} else {
+		color_printf(colors_string, "%s", string);
+	}
+	printf("\n");
+}
+
+const colordata_t COLOR_WHITE_ALL[] = {
+	{ SEP_ANY, COLOR_WHITE },
+	{ SEP_LINE, COLOR_NONE },
+	{ SEP_ANY, COLOR_END } };
+
+const colordata_t COLOR_GREEN_ALL[] = {
+	{ SEP_ANY, COLOR_GREEN },
+	{ SEP_LINE, COLOR_NONE },
+	{ SEP_ANY, COLOR_END } };
+
+const colordata_t COLOR_RED_ALL[] = {
+	{ SEP_ANY, COLOR_RED },
+	{ SEP_LINE, COLOR_NONE },
+	{ SEP_ANY, COLOR_END } };
+
+const colordata_t COLOR_BLUE_ALL[] = {
+	{ SEP_ANY, COLOR_BLUE },
+	{ SEP_LINE, COLOR_NONE },
+	{ SEP_ANY, COLOR_END } };
+
+const colordata_t COLOR_YELLOW_ALL[] = {
+	{ SEP_ANY, COLOR_YELLOW },
+	{ SEP_LINE, COLOR_NONE },
+	{ SEP_ANY, COLOR_END } };
+
+const colordata_t COLOR_MAGENTA_ALL[] = {
+	{ SEP_ANY, COLOR_MAGENTA },
+	{ SEP_LINE, COLOR_NONE },
+	{ SEP_ANY, COLOR_END } };
+
+const colordata_t COLOR_CYAN_ALL[] = {
+	{ SEP_ANY, COLOR_CYAN },
+	{ SEP_LINE, COLOR_NONE },
+	{ SEP_ANY, COLOR_END } };
+
+const colordata_t COLOR_DOUBLECOLON[] = {
+	{ SEP_ANY, COLOR_BLUE },
+	{ SEP_ANY, COLOR_SAME },
+	{ SEP_ANY, COLOR_WHITE },
+	{ SEP_LINE, COLOR_NONE },
+	{ SEP_ANY, COLOR_END } };
+
+const colordata_t COLOR_DOUBLECOLON2[] = {
+	{ SEP_ANY, COLOR_BLUE },
+	{ SEP_ANY, COLOR_SAME },
+	{ SEP_ANY, COLOR_WHITE },
+	{ SEP_LINE, COLOR_NONE },
+	{ SEP_ANY, COLOR_BLUE },
+	{ SEP_ANY, COLOR_SAME },
+	{ SEP_ANY, COLOR_WHITE },
+	{ SEP_LINE, COLOR_NONE },
+	{ SEP_ANY, COLOR_END } };
+
+const colordata_t COLOR_WHITE_COLON[] = {
+	{ SEP_ANY, COLOR_WHITE },
+	{ SEP_COLON, COLOR_SAME },
+	{ SEP_ANY, COLOR_NONE },
+	{ SEP_ANY, COLOR_END } };
+
 /* vim: set ts=2 sw=2 noet: */
diff -Naur pacman-3.3.3/src/pacman/util.h pacman-color-3.3.3/src/pacman/util.h
--- pacman-3.3.3/src/pacman/util.h	2009-09-30 03:38:36.000000000 +0200
+++ pacman-color-3.3.3/src/pacman/util.h	2009-11-11 17:38:37.000000000 +0100
@@ -37,6 +37,48 @@
 /* update speed for the fill_progress based functions */
 #define UPDATE_SPEED_SEC 0.2f
 
+/* pacman-color */
+typedef enum _separator_t {
+	SEP_ANY = 0,
+	SEP_LINE,
+	SEP_COLON,
+} separator_t;
+
+typedef enum _color_t {
+	COLOR_END = 0,
+	COLOR_SAME,
+	COLOR_RED,
+	COLOR_GREEN,
+	COLOR_YELLOW,
+	COLOR_BLUE,
+	COLOR_MAGENTA,
+	COLOR_CYAN,
+	COLOR_WHITE,
+	COLOR_NONE,
+} color_t;
+
+typedef struct _colordata_t {
+	separator_t separator;
+	color_t color;
+} colordata_t;
+
+extern const colordata_t COLOR_WHITE_ALL[];
+extern const colordata_t COLOR_GREEN_ALL[];
+extern const colordata_t COLOR_RED_ALL[];
+extern const colordata_t COLOR_BLUE_ALL[];
+extern const colordata_t COLOR_YELLOW_ALL[];
+extern const colordata_t COLOR_MAGENTA_ALL[];
+extern const colordata_t COLOR_CYAN_ALL[];
+extern const colordata_t COLOR_DOUBLECOLON[];
+extern const colordata_t COLOR_DOUBLECOLON2[];
+extern const colordata_t COLOR_WHITE_COLON[];
+
+int parsecolorconfig();
+int color_fprintf(FILE* stream, const colordata_t* colors, const char* format, ...) __attribute__((format(printf,3,4)));
+int color_printf(const colordata_t* colors, const char* format, ...) __attribute__((format(printf,2,3)));
+int color_vfprintf(FILE* stream, const colordata_t* colors, const char* format, va_list args) __attribute__((format(printf,3,0)));
+void color_string_display(const colordata_t* colors_title, const char* title, const colordata_t* colors_string, const char* string);
+
 int trans_init(pmtranstype_t type, pmtransflag_t flags);
 int trans_release(void);
 int needs_root(void);
@@ -50,15 +92,15 @@
 char *strtrim(char *str);
 char *strreplace(const char *str, const char *needle, const char *replace);
 alpm_list_t *strsplit(const char *str, const char splitchar);
-void string_display(const char *title, const char *string);
-void list_display(const char *title, const alpm_list_t *list);
-void list_display_linebreak(const char *title, const alpm_list_t *list);
+void string_display(const colordata_t *colors_title, const char *title, const char *string);
+void list_display(const colordata_t *colors_title, const char *title, const alpm_list_t *list);
+void list_display_linebreak(const colordata_t *colors_title, const char *title, const alpm_list_t *list);
 void display_targets(const alpm_list_t *pkgs, int install);
 void display_synctargets(const alpm_list_t *syncpkgs);
 void display_new_optdepends(pmpkg_t *oldpkg, pmpkg_t *newpkg);
 void display_optdepends(pmpkg_t *pkg);
-int yesno(char *fmt, ...);
-int noyes(char *fmt, ...);
+int yesno(const colordata_t *colors, char *fmt, ...);
+int noyes(const colordata_t *colors, char *fmt, ...);
 int pm_printf(pmloglevel_t level, const char *format, ...) __attribute__((format(printf,2,3)));
 int pm_fprintf(FILE *stream, pmloglevel_t level, const char *format, ...) __attribute__((format(printf,3,4)));
 int pm_vfprintf(FILE *stream, pmloglevel_t level, const char *format, va_list args) __attribute__((format(printf,3,0)));
