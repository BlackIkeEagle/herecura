diff -Naur pacman-3.5.2//src/pacman/callback.c pacman-color-3.5.2//src/pacman/callback.c
--- pacman-3.5.2//src/pacman/callback.c	2011-03-16 16:41:32.000000000 +0100
+++ pacman-color-3.5.2//src/pacman/callback.c	2011-04-19 17:21:28.000000000 +0200
@@ -218,16 +218,16 @@
 			printf(_("generating %s with %s... "), (char *)data1, (char *)data2);
 			break;
 		case PM_TRANS_EVT_DELTA_PATCH_DONE:
-			printf(_("success!\n"));
+			color_printf(COLOR_GREEN_ALL, _("success!\n"));
 			break;
 		case PM_TRANS_EVT_DELTA_PATCH_FAILED:
-			printf(_("failed.\n"));
+			color_printf(COLOR_RED_ALL, _("failed.\n"));
 			break;
 		case PM_TRANS_EVT_SCRIPTLET_INFO:
 			printf("%s", (char*)data1);
 			break;
 		case PM_TRANS_EVT_RETRIEVE_START:
-			printf(_(":: Retrieving packages from %s...\n"), (char*)data1);
+			color_printf(COLOR_DOUBLECOLON, _(":: Retrieving packages from %s...\n"), (char*)data1);
 			break;
 		case PM_TRANS_EVT_DISKSPACE_START:
 			if(config->noprogressbar) {
@@ -256,11 +256,11 @@
 {
 	switch(event) {
 		case PM_TRANS_CONV_INSTALL_IGNOREPKG:
-			*response = yesno(_(":: %s is in IgnorePkg/IgnoreGroup. Install anyway?"),
+			*response = yesno(COLOR_DOUBLECOLON, _(":: %s is in IgnorePkg/IgnoreGroup. Install anyway?"),
 							  alpm_pkg_get_name(data1));
 			break;
 		case PM_TRANS_CONV_REPLACE_PKG:
-			*response = yesno(_(":: Replace %s with %s/%s?"),
+			*response = yesno(COLOR_DOUBLECOLON, _(":: Replace %s with %s/%s?"),
 					alpm_pkg_get_name(data1),
 					(char *)data3,
 					alpm_pkg_get_name(data2));
@@ -269,12 +269,12 @@
 			/* data parameters: target package, local package, conflict (strings) */
 			/* print conflict only if it contains new information */
 			if(strcmp(data1, data3) == 0 || strcmp(data2, data3) == 0) {
-				*response = noyes(_(":: %s and %s are in conflict. Remove %s?"),
+				*response = noyes(COLOR_DOUBLECOLON, _(":: %s and %s are in conflict. Remove %s?"),
 						(char *)data1,
 						(char *)data2,
 						(char *)data2);
 			} else {
-				*response = noyes(_(":: %s and %s are in conflict (%s). Remove %s?"),
+				*response = noyes(COLOR_DOUBLECOLON, _(":: %s and %s are in conflict (%s). Remove %s?"),
 						(char *)data1,
 						(char *)data2,
 						(char *)data3,
@@ -291,13 +291,13 @@
 							(char *)alpm_pkg_get_name(i->data));
 					count++;
 				}
-				printf(_n(
+				color_printf(COLOR_DOUBLECOLON, _n(
 							":: The following package cannot be upgraded due to unresolvable dependencies:\n",
 							":: The following packages cannot be upgraded due to unresolvable dependencies:\n",
 							count));
-				list_display("     ", namelist);
+				list_display(NULL, "     ", namelist);
 				printf("\n");
-				*response = noyes(_n(
+				*response = noyes(NULL, _n(
 							"Do you want to skip the above package for this upgrade?",
 							"Do you want to skip the above packages for this upgrade?",
 							count));
@@ -309,7 +309,7 @@
 				alpm_list_t *providers = (alpm_list_t *)data1;
 				int count = alpm_list_count(providers);
 				char *depstring = alpm_dep_compute_string((pmdepend_t *)data2);
-				printf(_(":: There are %d providers available for %s:\n"), count,
+				color_printf(COLOR_DOUBLECOLON, _(":: There are %d providers available for %s:\n"), count,
 						depstring);
 				free(depstring);
 				select_display(providers);
@@ -318,7 +318,7 @@
 			break;
 		case PM_TRANS_CONV_LOCAL_NEWER:
 			if(!config->op_s_downloadonly) {
-				*response = yesno(_(":: %s-%s: local version is newer. Upgrade anyway?"),
+				*response = yesno(COLOR_DOUBLECOLON, _(":: %s-%s: local version is newer. Upgrade anyway?"),
 						alpm_pkg_get_name(data1),
 						alpm_pkg_get_version(data1));
 			} else {
@@ -326,7 +326,7 @@
 			}
 			break;
 		case PM_TRANS_CONV_CORRUPTED_PKG:
-			*response = yesno(_(":: File %s is corrupted. Do you want to delete it?"),
+			*response = yesno(COLOR_DOUBLECOLON, _(":: File %s is corrupted. Do you want to delete it?"),
 					(char *)data1);
 			break;
 	}
@@ -448,8 +448,9 @@
 
 	}
 
-	printf("(%*ld/%*ld) %ls%-*s", digits, (unsigned long)current,
-			digits, (unsigned long)howmany, wcstr, padwid, "");
+	color_printf(COLOR_BLUE_ALL, "(%*ld/%*ld)", digits, (unsigned long)current,
+				 digits, (unsigned long)howmany);
+	printf(" %ls%-*s", wcstr, padwid, "");
 
 	free(wcstr);
 
diff -Naur pacman-3.5.2//src/pacman/package.c pacman-color-3.5.2//src/pacman/package.c
--- pacman-3.5.2//src/pacman/package.c	2011-02-28 18:13:17.000000000 +0100
+++ pacman-color-3.5.2//src/pacman/package.c	2011-04-19 17:21:28.000000000 +0200
@@ -92,47 +92,47 @@
 	}
 
 	/* actual output */
-	string_display(_("Name           :"), alpm_pkg_get_name(pkg));
-	string_display(_("Version        :"), alpm_pkg_get_version(pkg));
-	string_display(_("URL            :"), alpm_pkg_get_url(pkg));
-	list_display(_("Licenses       :"), alpm_pkg_get_licenses(pkg));
-	list_display(_("Groups         :"), alpm_pkg_get_groups(pkg));
-	list_display(_("Provides       :"), alpm_pkg_get_provides(pkg));
-	list_display(_("Depends On     :"), depstrings);
-	list_display_linebreak(_("Optional Deps  :"), alpm_pkg_get_optdepends(pkg));
+	color_string_display(COLOR_WHITE_ALL, _("Name           :"), COLOR_WHITE_ALL, alpm_pkg_get_name(pkg));
+	color_string_display(COLOR_WHITE_ALL, _("Version        :"), COLOR_GREEN_ALL, alpm_pkg_get_version(pkg));
+	color_string_display(COLOR_WHITE_ALL, _("URL            :"), COLOR_CYAN_ALL, alpm_pkg_get_url(pkg));
+	list_display(COLOR_WHITE_ALL, _("Licenses       :"), alpm_pkg_get_licenses(pkg));
+	list_display(COLOR_WHITE_ALL, _("Groups         :"), alpm_pkg_get_groups(pkg));
+	list_display(COLOR_WHITE_ALL, _("Provides       :"), alpm_pkg_get_provides(pkg));
+	list_display(COLOR_WHITE_ALL, _("Depends On     :"), depstrings);
+	list_display_linebreak(COLOR_WHITE_ALL, _("Optional Deps  :"), alpm_pkg_get_optdepends(pkg));
 	if(level > 0 || level < -1) {
-		list_display(_("Required By    :"), requiredby);
+		list_display(COLOR_WHITE_ALL, _("Required By    :"), requiredby);
 	}
-	list_display(_("Conflicts With :"), alpm_pkg_get_conflicts(pkg));
-	list_display(_("Replaces       :"), alpm_pkg_get_replaces(pkg));
+	list_display(COLOR_WHITE_ALL, _("Conflicts With :"), alpm_pkg_get_conflicts(pkg));
+	list_display(COLOR_WHITE_ALL, _("Replaces       :"), alpm_pkg_get_replaces(pkg));
 	if(level < 0) {
-		printf(_("Download Size  : %6.2f K\n"),
+		color_printf(COLOR_WHITE_COLON, _("Download Size  : %6.2f K\n"),
 			(double)alpm_pkg_get_size(pkg) / 1024.0);
 	}
 	if(level == 0) {
-		printf(_("Compressed Size: %6.2f K\n"),
+		color_printf(COLOR_WHITE_COLON, _("Compressed Size: %6.2f K\n"),
 			(double)alpm_pkg_get_size(pkg) / 1024.0);
 	}
 
-	printf(_("Installed Size : %6.2f K\n"),
+	color_printf(COLOR_WHITE_COLON, _("Installed Size : %6.2f K\n"),
 			(double)alpm_pkg_get_isize(pkg) / 1024.0);
-	string_display(_("Packager       :"), alpm_pkg_get_packager(pkg));
-	string_display(_("Architecture   :"), alpm_pkg_get_arch(pkg));
-	string_display(_("Build Date     :"), bdatestr);
+	string_display(COLOR_WHITE_ALL, _("Packager       :"), alpm_pkg_get_packager(pkg));
+	string_display(COLOR_WHITE_ALL, _("Architecture   :"), alpm_pkg_get_arch(pkg));
+	string_display(COLOR_WHITE_ALL, _("Build Date     :"), bdatestr);
 	if(level > 0) {
-		string_display(_("Install Date   :"), idatestr);
-		string_display(_("Install Reason :"), reason);
+		string_display(COLOR_WHITE_ALL, _("Install Date   :"), idatestr);
+		string_display(COLOR_WHITE_ALL, _("Install Reason :"), reason);
 	}
 	if(level >= 0) {
-		string_display(_("Install Script :"),
+		string_display(COLOR_WHITE_ALL, _("Install Script :"),
 				alpm_pkg_has_scriptlet(pkg) ?  _("Yes") : _("No"));
 	}
 
 	/* MD5 Sum for sync package */
 	if(level < 0) {
-		string_display(_("MD5 Sum        :"), alpm_pkg_get_md5sum(pkg));
+		string_display(COLOR_WHITE_ALL, _("MD5 Sum        :"), alpm_pkg_get_md5sum(pkg));
 	}
-	string_display(_("Description    :"), alpm_pkg_get_desc(pkg));
+	string_display(COLOR_WHITE_ALL, _("Description    :"), alpm_pkg_get_desc(pkg));
 
 	/* Print additional package info if info flag passed more than once */
 	if(level > 1) {
@@ -153,7 +153,7 @@
 	if(pkg == NULL) {
 		return;
 	}
-	string_display(_("Repository     :"), treename);
+	color_string_display(COLOR_WHITE_ALL, _("Repository     :"), COLOR_MAGENTA_ALL, treename);
 	/* invert the level since we are a sync package */
 	dump_pkg_full(pkg, -level);
 }
@@ -204,7 +204,7 @@
 {
 	alpm_list_t *i;
 	const char *root = alpm_option_get_root();
-	printf(_("Backup Files:\n"));
+	color_printf(COLOR_WHITE_ALL, _("Backup Files:\n"));
 	if(alpm_pkg_get_backup(pkg)) {
 		/* package has backup files, so print them */
 		for(i = alpm_pkg_get_backup(pkg); i; i = alpm_list_next(i)) {
@@ -241,7 +241,8 @@
 	for(i = pkgfiles; i; i = alpm_list_next(i)) {
 		filestr = alpm_list_getdata(i);
 		if(!quiet){
-			fprintf(stdout, "%s %s%s\n", pkgname, root, filestr);
+			color_fprintf(stdout, COLOR_WHITE_ALL, "%s", pkgname);
+			fprintf(stdout, " %s%s\n", root, filestr);
 		} else {
 			fprintf(stdout, "%s%s\n", root, filestr);
 		}
diff -Naur pacman-3.5.2//src/pacman/pacman.c pacman-color-3.5.2//src/pacman/pacman.c
--- pacman-3.5.2//src/pacman/pacman.c	2011-03-25 21:39:43.000000000 +0100
+++ pacman-color-3.5.2//src/pacman/pacman.c	2011-04-19 17:21:28.000000000 +0200
@@ -222,11 +222,22 @@
  */
 static void version(void)
 {
-	printf("\n");
-	printf(" .--.                  Pacman v%s - libalpm v%s\n", PACKAGE_VERSION, alpm_version());
-	printf("/ _.-' .-.  .-.  .-.   Copyright (C) 2006-2011 Pacman Development Team\n");
-	printf("\\  '-. '-'  '-'  '-'   Copyright (C) 2002-2006 Judd Vinet\n");
-	printf(" '--'\n");
+	color_printf(COLOR_YELLOW_ALL, " .--. ");
+	printf("        ");
+	color_printf(COLOR_RED_ALL, " .---. ");
+	printf("  Pacman-color v%s - libalpm v%s\n", PACKAGE_VERSION, alpm_version());
+	color_printf(COLOR_YELLOW_ALL, "/ _.-'");
+	color_printf(COLOR_WHITE_ALL, " .-.  .-");
+	color_printf(COLOR_RED_ALL, "|O O  |");
+	printf("  Copyright (C) 2006-2011 Pacman Development Team\n");
+	color_printf(COLOR_YELLOW_ALL, "\\  '-.");
+	color_printf(COLOR_WHITE_ALL, " '-'  '-");
+	color_printf(COLOR_RED_ALL, "|~~~  |");
+	printf("  Copyright (C) 2002-2006 Judd Vinet\n");
+	color_printf(COLOR_YELLOW_ALL, " '--' ");
+	printf("        ");
+	color_printf(COLOR_RED_ALL, "|.-.-.|");
+	printf("  Colored by vogo <vogo(at)seznam(dot)cz>\n");
 	printf(_("                       This program may be freely redistributed under\n"
 	         "                       the terms of the GNU General Public License.\n"));
 	printf("\n");
@@ -1326,6 +1337,7 @@
 
 	/* init config data */
 	config = config_new();
+	parsecolorconfig();
 
 	/* disable progressbar if the output is redirected */
 	if(!isatty(1)) {
@@ -1434,17 +1446,17 @@
 
 	if(config->verbose > 0) {
 		alpm_list_t *i;
-		printf("Root      : %s\n", alpm_option_get_root());
-		printf("Conf File : %s\n", config->configfile);
-		printf("DB Path   : %s\n", alpm_option_get_dbpath());
-		printf("Cache Dirs: ");
+		string_display(COLOR_WHITE_ALL, "Root      :", alpm_option_get_root());
+		string_display(COLOR_WHITE_ALL, "Conf File :", config->configfile);
+		string_display(COLOR_WHITE_ALL, "DB Path   :", alpm_option_get_dbpath());
+		color_printf(COLOR_WHITE_ALL, "Cache Dirs: ");
 		for(i = alpm_option_get_cachedirs(); i; i = alpm_list_next(i)) {
 			printf("%s  ", (char*)alpm_list_getdata(i));
 		}
 		printf("\n");
-		printf("Lock File : %s\n", alpm_option_get_lockfile());
-		printf("Log File  : %s\n", alpm_option_get_logfile());
-		list_display("Targets   :", pm_targets);
+		string_display(COLOR_WHITE_ALL, "Lock File :", alpm_option_get_lockfile());
+		string_display(COLOR_WHITE_ALL, "Log File  :", alpm_option_get_logfile());
+		list_display(COLOR_WHITE_ALL, "Targets   :", pm_targets);
 	}
 
 	/* Log commandline */
diff -Naur pacman-3.5.2//src/pacman/pacman.c.orig pacman-color-3.5.2//src/pacman/pacman.c.orig
--- pacman-3.5.2//src/pacman/pacman.c.orig	1970-01-01 01:00:00.000000000 +0100
+++ pacman-color-3.5.2//src/pacman/pacman.c.orig	2011-03-25 21:39:43.000000000 +0100
@@ -0,0 +1,1485 @@
+/*
+ *  pacman.c
+ *
+ *  Copyright (c) 2006-2011 Pacman Development Team <pacman-dev@archlinux.org>
+ *  Copyright (c) 2002-2006 by Judd Vinet <jvinet@zeroflux.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "config.h"
+
+/* special handling of package version for GIT */
+#if defined(GIT_VERSION)
+#undef PACKAGE_VERSION
+#define PACKAGE_VERSION GIT_VERSION
+#endif
+
+#include <ctype.h> /* isspace */
+#include <stdlib.h> /* atoi */
+#include <stdio.h>
+#include <ctype.h> /* isspace */
+#include <limits.h>
+#include <getopt.h>
+#include <string.h>
+#include <signal.h>
+#include <unistd.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/utsname.h> /* uname */
+#include <locale.h> /* setlocale */
+#include <time.h> /* time_t */
+#include <errno.h>
+#include <glob.h>
+#if defined(PACMAN_DEBUG) && defined(HAVE_MCHECK_H)
+#include <mcheck.h> /* debug tracing (mtrace) */
+#endif
+
+/* alpm */
+#include <alpm.h>
+#include <alpm_list.h>
+
+/* pacman */
+#include "pacman.h"
+#include "util.h"
+#include "callback.h"
+#include "conf.h"
+#include "package.h"
+
+/* list of targets specified on command line */
+static alpm_list_t *pm_targets;
+
+/* Used to sort the options in --help */
+static int options_cmp(const void *p1, const void *p2)
+{
+	const char *s1 = p1;
+	const char *s2 = p2;
+
+	if(s1 == s2) return(0);
+	if(!s1) return(-1);
+	if(!s2) return(1);
+	/* First skip all spaces in both strings */
+	while(isspace((unsigned char)*s1)) {
+		s1++;
+	}
+	while(isspace((unsigned char)*s2)) {
+		s2++;
+	}
+	/* If we compare a long option (--abcd) and a short one (-a),
+	 * the short one always wins */
+	if(*s1 == '-' && *s2 == '-') {
+		s1++;
+		s2++;
+		if(*s1 == '-' && *s2 == '-') {
+			/* two long -> strcmp */
+			s1++;
+			s2++;
+		} else if(*s2 == '-') {
+			/* s1 short, s2 long */
+			return(-1);
+		} else if(*s1 == '-') {
+			/* s1 long, s2 short */
+			return(1);
+		}
+		/* two short -> strcmp */
+	}
+
+	return(strcmp(s1, s2));
+}
+
+/** Display usage/syntax for the specified operation.
+ * @param op     the operation code requested
+ * @param myname basename(argv[0])
+ */
+static void usage(int op, const char * const myname)
+{
+#define addlist(s) (list = alpm_list_add(list, s))
+	alpm_list_t *list = NULL, *i;
+	/* prefetch some strings for usage below, which moves a lot of calls
+	 * out of gettext. */
+	char const * const str_opt = _("options");
+	char const * const str_file = _("file(s)");
+	char const * const str_pkg = _("package(s)");
+	char const * const str_usg = _("usage");
+	char const * const str_opr = _("operation");
+
+	/* please limit your strings to 80 characters in width */
+	if(op == PM_OP_MAIN) {
+		printf("%s:  %s <%s> [...]\n", str_usg, myname, str_opr);
+		printf(_("operations:\n"));
+		printf("    %s {-h --help}\n", myname);
+		printf("    %s {-V --version}\n", myname);
+		printf("    %s {-D --database} <%s> <%s>\n", myname, str_opt, str_pkg);
+		printf("    %s {-Q --query}    [%s] [%s]\n", myname, str_opt, str_pkg);
+		printf("    %s {-R --remove}   [%s] <%s>\n", myname, str_opt, str_pkg);
+		printf("    %s {-S --sync}     [%s] [%s]\n", myname, str_opt, str_pkg);
+		printf("    %s {-T --deptest}  [%s] [%s]\n", myname, str_opt, str_pkg);
+		printf("    %s {-U --upgrade}  [%s] <%s>\n", myname, str_opt, str_file);
+		printf(_("\nuse '%s {-h --help}' with an operation for available options\n"),
+				myname);
+	} else {
+		if(op == PM_OP_REMOVE) {
+			printf("%s:  %s {-R --remove} [%s] <%s>\n", str_usg, myname, str_opt, str_pkg);
+			printf("%s:\n", str_opt);
+			addlist(_("  -c, --cascade        remove packages and all packages that depend on them\n"));
+			addlist(_("  -n, --nosave         remove configuration files\n"));
+			addlist(_("  -s, --recursive      remove unnecessary dependencies\n"
+			          "                       (-ss includes explicitly installed dependencies)\n"));
+			addlist(_("  -u, --unneeded       remove unneeded packages\n"));
+		} else if(op == PM_OP_UPGRADE) {
+			printf("%s:  %s {-U --upgrade} [%s] <%s>\n", str_usg, myname, str_opt, str_file);
+			printf("%s:\n", str_opt);
+		} else if(op == PM_OP_QUERY) {
+			printf("%s:  %s {-Q --query} [%s] [%s]\n", str_usg, myname, str_opt, str_pkg);
+			printf("%s:\n", str_opt);
+			addlist(_("  -c, --changelog      view the changelog of a package\n"));
+			addlist(_("  -d, --deps           list packages installed as dependencies [filter]\n"));
+			addlist(_("  -e, --explicit       list packages explicitly installed [filter]\n"));
+			addlist(_("  -g, --groups         view all members of a package group\n"));
+			addlist(_("  -i, --info           view package information (-ii for backup files)\n"));
+			addlist(_("  -k, --check          check that the files owned by the package(s) are present\n"));
+			addlist(_("  -l, --list           list the contents of the queried package\n"));
+			addlist(_("  -m, --foreign        list installed packages not found in sync db(s) [filter]\n"));
+			addlist(_("  -o, --owns <file>    query the package that owns <file>\n"));
+			addlist(_("  -p, --file <package> query a package file instead of the database\n"));
+			addlist(_("  -q, --quiet          show less information for query and search\n"));
+			addlist(_("  -s, --search <regex> search locally-installed packages for matching strings\n"));
+			addlist(_("  -t, --unrequired     list packages not required by any package [filter]\n"));
+			addlist(_("  -u, --upgrades       list outdated packages [filter]\n"));
+		} else if(op == PM_OP_SYNC) {
+			printf("%s:  %s {-S --sync} [%s] [%s]\n", str_usg, myname, str_opt, str_pkg);
+			printf("%s:\n", str_opt);
+			addlist(_("  -c, --clean          remove old packages from cache directory (-cc for all)\n"));
+			addlist(_("  -g, --groups         view all members of a package group\n"));
+			addlist(_("  -i, --info           view package information\n"));
+			addlist(_("  -l, --list <repo>    view a list of packages in a repo\n"));
+			addlist(_("  -q, --quiet          show less information for query and search\n"));
+			addlist(_("  -s, --search <regex> search remote repositories for matching strings\n"));
+			addlist(_("  -u, --sysupgrade     upgrade installed packages (-uu allows downgrade)\n"));
+			addlist(_("  -w, --downloadonly   download packages but do not install/upgrade anything\n"));
+			addlist(_("  -y, --refresh        download fresh package databases from the server\n"));
+			addlist(_("      --needed         don't reinstall up to date packages\n"));
+		} else if (op == PM_OP_DATABASE) {
+			printf("%s:  %s {-D --database} <%s> <%s>\n", str_usg, myname, str_opt, str_pkg);
+			printf("%s:\n", str_opt);
+			addlist(_("      --asdeps         mark packages as non-explicitly installed\n"));
+			addlist(_("      --asexplicit     mark packages as explicitly installed\n"));
+		} else if(op == PM_OP_DEPTEST) {
+			printf("%s:  %s {-T --deptest} [%s] [%s]\n", str_usg, myname, str_opt, str_pkg);
+			printf("%s:\n", str_opt);
+		}
+		switch(op) {
+			case PM_OP_SYNC:
+			case PM_OP_UPGRADE:
+				addlist(_("  -f, --force          force install, overwrite conflicting files\n"));
+				addlist(_("      --asdeps         install packages as non-explicitly installed\n"));
+				addlist(_("      --asexplicit     install packages as explicitly installed\n"));
+				addlist(_("      --ignore <pkg>   ignore a package upgrade (can be used more than once)\n"));
+				addlist(_("      --ignoregroup <grp>\n"
+				          "                       ignore a group upgrade (can be used more than once)\n"));
+				/* pass through */
+			case PM_OP_REMOVE:
+				addlist(_("  -d, --nodeps         skip dependency version checks (-dd to skip all checks)\n"));
+				addlist(_("  -k, --dbonly         only modify database entries, not package files\n"));
+				addlist(_("      --noprogressbar  do not show a progress bar when downloading files\n"));
+				addlist(_("      --noscriptlet    do not execute the install scriptlet if one exists\n"));
+				addlist(_("      --print          print the targets instead of performing the operation\n"));
+				addlist(_("      --print-format <string>\n"
+				          "                       specify how the targets should be printed\n"));
+				break;
+		}
+
+		addlist(_("  -b, --dbpath <path>  set an alternate database location\n"));
+		addlist(_("  -r, --root <path>    set an alternate installation root\n"));
+		addlist(_("  -v, --verbose        be verbose\n"));
+		addlist(_("      --arch <arch>    set an alternate architecture\n"));
+		addlist(_("      --cachedir <dir> set an alternate package cache location\n"));
+		addlist(_("      --config <path>  set an alternate configuration file\n"));
+		addlist(_("      --debug          display debug messages\n"));
+		addlist(_("      --logfile <path> set an alternate log file\n"));
+		addlist(_("      --noconfirm      do not ask for any confirmation\n"));
+	}
+	list = alpm_list_msort(list, alpm_list_count(list), options_cmp);
+	for (i = list; i; i = alpm_list_next(i)) {
+		printf("%s", (char *)alpm_list_getdata(i));
+	}
+	alpm_list_free(list);
+#undef addlist
+}
+
+/** Output pacman version and copyright.
+ */
+static void version(void)
+{
+	printf("\n");
+	printf(" .--.                  Pacman v%s - libalpm v%s\n", PACKAGE_VERSION, alpm_version());
+	printf("/ _.-' .-.  .-.  .-.   Copyright (C) 2006-2011 Pacman Development Team\n");
+	printf("\\  '-. '-'  '-'  '-'   Copyright (C) 2002-2006 Judd Vinet\n");
+	printf(" '--'\n");
+	printf(_("                       This program may be freely redistributed under\n"
+	         "                       the terms of the GNU General Public License.\n"));
+	printf("\n");
+}
+
+/** Sets up gettext localization. Safe to call multiple times.
+ */
+/* Inspired by the monotone function localize_monotone. */
+#if defined(ENABLE_NLS)
+static void localize(void)
+{
+	static int init = 0;
+	if (!init) {
+		setlocale(LC_ALL, "");
+		bindtextdomain(PACKAGE, LOCALEDIR);
+		textdomain(PACKAGE);
+		init = 1;
+	}
+}
+#endif
+
+/** Set user agent environment variable.
+ */
+static void setuseragent(void)
+{
+	char agent[101];
+	struct utsname un;
+
+	uname(&un);
+	snprintf(agent, 100, "pacman/%s (%s %s) libalpm/%s",
+			PACKAGE_VERSION, un.sysname, un.machine, alpm_version());
+	setenv("HTTP_USER_AGENT", agent, 0);
+}
+
+static void setarch(const char *arch)
+{
+	if (strcmp(arch, "auto") == 0) {
+		struct utsname un;
+		uname(&un);
+		pm_printf(PM_LOG_DEBUG, "config: Architecture: %s\n", un.machine);
+		alpm_option_set_arch(un.machine);
+	} else {
+		pm_printf(PM_LOG_DEBUG, "config: Architecture: %s\n", arch);
+		alpm_option_set_arch(arch);
+	}
+}
+
+/** Free the resources.
+ *
+ * @param ret the return value
+ */
+static void cleanup(int ret) {
+	/* free alpm library resources */
+	if(alpm_release() == -1) {
+		pm_printf(PM_LOG_ERROR, "%s\n", alpm_strerrorlast());
+	}
+
+	/* free memory */
+	FREELIST(pm_targets);
+	if(config) {
+		config_free(config);
+		config = NULL;
+	}
+
+	exit(ret);
+}
+
+/** Write function that correctly handles EINTR.
+ */
+static ssize_t xwrite(int fd, const void *buf, size_t count)
+{
+	ssize_t ret;
+	do {
+		ret = write(fd, buf, count);
+	} while(ret == -1 && errno == EINTR);
+	return(ret);
+}
+
+/** Catches thrown signals. Performs necessary cleanup to ensure database is
+ * in a consistant state.
+ * @param signum the thrown signal
+ */
+static void handler(int signum)
+{
+	int out = fileno(stdout);
+	int err = fileno(stderr);
+	if(signum == SIGSEGV) {
+		const char *msg1 = "error: segmentation fault\n";
+		const char *msg2 = "Internal pacman error: Segmentation fault.\n"
+			"Please submit a full bug report with --debug if appropriate.\n";
+		/* write a error message to out, the rest to err */
+		xwrite(out, msg1, strlen(msg1));
+		xwrite(err, msg2, strlen(msg2));
+		exit(signum);
+	} else if((signum == SIGINT)) {
+		const char *msg = "\nInterrupt signal received\n";
+		xwrite(err, msg, strlen(msg));
+		if(alpm_trans_interrupt() == 0) {
+			/* a transaction is being interrupted, don't exit pacman yet. */
+			return;
+		}
+		/* no commiting transaction, we can release it now and then exit pacman */
+		alpm_trans_release();
+		/* output a newline to be sure we clear any line we may be on */
+		xwrite(out, "\n", 1);
+	}
+	cleanup(signum);
+}
+
+/** Sets all libalpm required paths in one go. Called after the command line
+ * and inital config file parsing. Once this is complete, we can see if any
+ * paths were defined. If a rootdir was defined and nothing else, we want all
+ * of our paths to live under the rootdir that was specified. Safe to call
+ * multiple times (will only do anything the first time).
+ */
+static void setlibpaths(void)
+{
+	static int init = 0;
+	if (!init) {
+		int ret = 0;
+
+		pm_printf(PM_LOG_DEBUG, "setlibpaths() called\n");
+		/* Configure root path first. If it is set and dbpath/logfile were not
+		 * set, then set those as well to reside under the root. */
+		if(config->rootdir) {
+			char path[PATH_MAX];
+			ret = alpm_option_set_root(config->rootdir);
+			if(ret != 0) {
+				pm_printf(PM_LOG_ERROR, _("problem setting rootdir '%s' (%s)\n"),
+						config->rootdir, alpm_strerrorlast());
+				cleanup(ret);
+			}
+			if(!config->dbpath) {
+				/* omit leading slash from our static DBPATH, root handles it */
+				snprintf(path, PATH_MAX, "%s%s", alpm_option_get_root(), DBPATH + 1);
+				config->dbpath = strdup(path);
+			}
+			if(!config->logfile) {
+				/* omit leading slash from our static LOGFILE path, root handles it */
+				snprintf(path, PATH_MAX, "%s%s", alpm_option_get_root(), LOGFILE + 1);
+				config->logfile = strdup(path);
+			}
+		}
+		/* Set other paths if they were configured. Note that unless rootdir
+		 * was left undefined, these two paths (dbpath and logfile) will have
+		 * been set locally above, so the if cases below will now trigger. */
+		if(config->dbpath) {
+			ret = alpm_option_set_dbpath(config->dbpath);
+			if(ret != 0) {
+				pm_printf(PM_LOG_ERROR, _("problem setting dbpath '%s' (%s)\n"),
+						config->dbpath, alpm_strerrorlast());
+				cleanup(ret);
+			}
+		}
+		if(config->logfile) {
+			ret = alpm_option_set_logfile(config->logfile);
+			if(ret != 0) {
+				pm_printf(PM_LOG_ERROR, _("problem setting logfile '%s' (%s)\n"),
+						config->logfile, alpm_strerrorlast());
+				cleanup(ret);
+			}
+		}
+
+		/* add a default cachedir if one wasn't specified */
+		if(alpm_option_get_cachedirs() == NULL) {
+			alpm_option_add_cachedir(CACHEDIR);
+		}
+		init = 1;
+	}
+}
+
+#define check_optarg() if(!optarg) { return(1); }
+
+typedef void (*fn_add) (const char *s);
+
+static int parsearg_util_addlist(fn_add fn)
+{
+	alpm_list_t *list = NULL, *item = NULL; /* lists for splitting strings */
+
+	check_optarg();
+	list = strsplit(optarg, ',');
+	for(item = list; item; item = alpm_list_next(item)) {
+		fn((char *)alpm_list_getdata(item));
+	}
+	FREELIST(list);
+	return(0);
+}
+
+/** Helper function for parsing operation from command-line arguments.
+ * @param opt Keycode returned by getopt_long
+ * @param dryrun If nonzero, application state is NOT changed
+ * @return 0 if opt was handled, 1 if it was not handled
+ */
+static int parsearg_op(int opt, int dryrun)
+{
+	switch(opt) {
+		/* operations */
+		case 'D':
+			if(dryrun) break;
+			config->op = (config->op != PM_OP_MAIN ? 0 : PM_OP_DATABASE); break;
+		case 'Q':
+			if(dryrun) break;
+			config->op = (config->op != PM_OP_MAIN ? 0 : PM_OP_QUERY); break;
+		case 'R':
+			if(dryrun) break;
+			config->op = (config->op != PM_OP_MAIN ? 0 : PM_OP_REMOVE); break;
+		case 'S':
+			if(dryrun) break;
+			config->op = (config->op != PM_OP_MAIN ? 0 : PM_OP_SYNC); break;
+		case 'T':
+			if(dryrun) break;
+			config->op = (config->op != PM_OP_MAIN ? 0 : PM_OP_DEPTEST); break;
+		case 'U':
+			if(dryrun) break;
+			config->op = (config->op != PM_OP_MAIN ? 0 : PM_OP_UPGRADE); break;
+		case 'V':
+			if(dryrun) break;
+			config->version = 1; break;
+		case 'h':
+			if(dryrun) break;
+			config->help = 1; break;
+		default:
+			return(1);
+	}
+	return(0);
+}
+
+/** Helper functions for parsing command-line arguments.
+ * @param opt Keycode returned by getopt_long
+ * @return 0 on success, 1 on failure
+ */
+static int parsearg_global(int opt)
+{
+	switch(opt) {
+		case OP_ARCH: check_optarg(); setarch(optarg); break;
+		case OP_ASK:
+			check_optarg();
+			config->noask = 1;
+			config->ask = (unsigned int)atoi(optarg);
+			break;
+		case OP_CACHEDIR:
+			check_optarg();
+			if(alpm_option_add_cachedir(optarg) != 0) {
+				pm_printf(PM_LOG_ERROR, _("problem adding cachedir '%s' (%s)\n"),
+						optarg, alpm_strerrorlast());
+				return(1);
+			}
+			break;
+		case OP_CONFIG:
+			check_optarg();
+			if(config->configfile) {
+				free(config->configfile);
+			}
+			config->configfile = strndup(optarg, PATH_MAX);
+			break;
+		case OP_DEBUG:
+			/* debug levels are made more 'human readable' than using a raw logmask
+			 * here, error and warning are set in config_new, though perhaps a
+			 * --quiet option will remove these later */
+			if(optarg) {
+				unsigned short debug = (unsigned short)atoi(optarg);
+				switch(debug) {
+					case 2:
+						config->logmask |= PM_LOG_FUNCTION; /* fall through */
+					case 1:
+						config->logmask |= PM_LOG_DEBUG;
+						break;
+					default:
+						pm_printf(PM_LOG_ERROR, _("'%s' is not a valid debug level\n"),
+								optarg);
+						return(1);
+				}
+			} else {
+				config->logmask |= PM_LOG_DEBUG;
+			}
+			/* progress bars get wonky with debug on, shut them off */
+			config->noprogressbar = 1;
+			break;
+		case OP_LOGFILE:
+			check_optarg();
+			config->logfile = strndup(optarg, PATH_MAX);
+			break;
+		case OP_NOCONFIRM: config->noconfirm = 1; break;
+		case 'b':
+			check_optarg();
+			config->dbpath = strdup(optarg);
+			break;
+		case 'r': check_optarg(); config->rootdir = strdup(optarg); break;
+		case 'v': (config->verbose)++; break;
+		default: return(1);
+	}
+	return(0);
+}
+
+static int parsearg_database(int opt)
+{
+	switch(opt) {
+		case OP_ASDEPS: config->flags |= PM_TRANS_FLAG_ALLDEPS; break;
+		case OP_ASEXPLICIT: config->flags |= PM_TRANS_FLAG_ALLEXPLICIT; break;
+		default: return(1);
+	}
+	return(0);
+}
+
+static int parsearg_query(int opt)
+{
+	switch(opt) {
+		case 'c': config->op_q_changelog = 1; break;
+		case 'd': config->op_q_deps = 1; break;
+		case 'e': config->op_q_explicit = 1; break;
+		case 'g': (config->group)++; break;
+		case 'i': (config->op_q_info)++; break;
+		case 'k': config->op_q_check = 1; break;
+		case 'l': config->op_q_list = 1; break;
+		case 'm': config->op_q_foreign = 1; break;
+		case 'o': config->op_q_owns = 1; break;
+		case 'p': config->op_q_isfile = 1; break;
+		case 'q': config->quiet = 1; break;
+		case 's': config->op_q_search = 1; break;
+		case 't': config->op_q_unrequired = 1; break;
+		case 'u': config->op_q_upgrade = 1; break;
+		default: return(1);
+	}
+	return(0);
+}
+
+/* options common to -S -R -U */
+static int parsearg_trans(int opt)
+{
+	switch(opt) {
+		case 'd':
+			if(config->flags & PM_TRANS_FLAG_NODEPVERSION) {
+				config->flags |= PM_TRANS_FLAG_NODEPS;
+			} else {
+				config->flags |= PM_TRANS_FLAG_NODEPVERSION;
+			}
+			break;
+		case 'k': config->flags |= PM_TRANS_FLAG_DBONLY; break;
+		case OP_NOPROGRESSBAR: config->noprogressbar = 1; break;
+		case OP_NOSCRIPTLET: config->flags |= PM_TRANS_FLAG_NOSCRIPTLET; break;
+		case 'p': config->print = 1; break;
+		case OP_PRINTFORMAT:
+			check_optarg();
+			config->print_format = strdup(optarg);
+			break;
+		default: return(1);
+	}
+	return(0);
+}
+
+static int parsearg_remove(int opt)
+{
+	if (parsearg_trans(opt) == 0)
+		return(0);
+	switch(opt) {
+		case 'c': config->flags |= PM_TRANS_FLAG_CASCADE; break;
+		case 'n': config->flags |= PM_TRANS_FLAG_NOSAVE; break;
+		case 's':
+			if(config->flags & PM_TRANS_FLAG_RECURSE) {
+				config->flags |= PM_TRANS_FLAG_RECURSEALL;
+			} else {
+				config->flags |= PM_TRANS_FLAG_RECURSE;
+			}
+			break;
+		case 'u': config->flags |= PM_TRANS_FLAG_UNNEEDED; break;
+		default: return(1);
+	}
+	return(0);
+}
+
+/* options common to -S -U */
+static int parsearg_upgrade(int opt)
+{
+	if (parsearg_trans(opt) == 0)
+		return(0);
+	switch(opt) {
+		case 'f': config->flags |= PM_TRANS_FLAG_FORCE; break;
+		case OP_ASDEPS: config->flags |= PM_TRANS_FLAG_ALLDEPS; break;
+		case OP_ASEXPLICIT: config->flags |= PM_TRANS_FLAG_ALLEXPLICIT; break;
+		case OP_IGNORE:
+			parsearg_util_addlist(alpm_option_add_ignorepkg);
+			break;
+		case OP_IGNOREGROUP:
+			parsearg_util_addlist(alpm_option_add_ignoregrp);
+			break;
+		default: return(1);
+	}
+	return(0);
+}
+
+static int parsearg_sync(int opt)
+{
+	if (parsearg_upgrade(opt) == 0)
+		return(0);
+	switch(opt) {
+		case OP_NEEDED: config->flags |= PM_TRANS_FLAG_NEEDED; break;
+		case 'c': (config->op_s_clean)++; break;
+		case 'g': (config->group)++; break;
+		case 'i': (config->op_s_info)++; break;
+		case 'l': config->op_q_list = 1; break;
+		case 'q': config->quiet = 1; break;
+		case 's': config->op_s_search = 1; break;
+		case 'u': (config->op_s_upgrade)++; break;
+		case 'w':
+			config->op_s_downloadonly = 1;
+			config->flags |= PM_TRANS_FLAG_DOWNLOADONLY;
+			config->flags |= PM_TRANS_FLAG_NOCONFLICTS;
+			break;
+		case 'y': (config->op_s_sync)++; break;
+		default: return(1);
+	}
+	return(0);
+}
+
+/** Parse command-line arguments for each operation.
+ * @param argc argc
+ * @param argv argv
+ * @return 0 on success, 1 on error
+ */
+static int parseargs(int argc, char *argv[])
+{
+	int opt;
+	int option_index = 0;
+	int result;
+	const char *optstring = "DQRSTUVb:cdefghiklmnopqr:stuvwy";
+	static struct option opts[] =
+	{
+		{"database",   no_argument,       0, 'D'},
+		{"query",      no_argument,       0, 'Q'},
+		{"remove",     no_argument,       0, 'R'},
+		{"sync",       no_argument,       0, 'S'},
+		{"deptest",    no_argument,       0, 'T'}, /* used by makepkg */
+		{"upgrade",    no_argument,       0, 'U'},
+		{"version",    no_argument,       0, 'V'},
+		{"dbpath",     required_argument, 0, 'b'},
+		{"cascade",    no_argument,       0, 'c'},
+		{"changelog",  no_argument,       0, 'c'},
+		{"clean",      no_argument,       0, 'c'},
+		{"nodeps",     no_argument,       0, 'd'},
+		{"deps",       no_argument,       0, 'd'},
+		{"explicit",   no_argument,       0, 'e'},
+		{"force",      no_argument,       0, 'f'},
+		{"groups",     no_argument,       0, 'g'},
+		{"help",       no_argument,       0, 'h'},
+		{"info",       no_argument,       0, 'i'},
+		{"dbonly",     no_argument,       0, 'k'},
+		{"check",      no_argument,       0, 'k'},
+		{"list",       no_argument,       0, 'l'},
+		{"foreign",    no_argument,       0, 'm'},
+		{"nosave",     no_argument,       0, 'n'},
+		{"owns",       no_argument,       0, 'o'},
+		{"file",       no_argument,       0, 'p'},
+		{"print",      no_argument,       0, 'p'},
+		{"quiet",      no_argument,       0, 'q'},
+		{"root",       required_argument, 0, 'r'},
+		{"recursive",  no_argument,       0, 's'},
+		{"search",     no_argument,       0, 's'},
+		{"unrequired", no_argument,       0, 't'},
+		{"upgrades",   no_argument,       0, 'u'},
+		{"sysupgrade", no_argument,       0, 'u'},
+		{"unneeded",   no_argument,       0, 'u'},
+		{"verbose",    no_argument,       0, 'v'},
+		{"downloadonly", no_argument,     0, 'w'},
+		{"refresh",    no_argument,       0, 'y'},
+		{"noconfirm",  no_argument,       0, OP_NOCONFIRM},
+		{"config",     required_argument, 0, OP_CONFIG},
+		{"ignore",     required_argument, 0, OP_IGNORE},
+		{"debug",      optional_argument, 0, OP_DEBUG},
+		{"noprogressbar", no_argument,    0, OP_NOPROGRESSBAR},
+		{"noscriptlet", no_argument,      0, OP_NOSCRIPTLET},
+		{"ask",        required_argument, 0, OP_ASK},
+		{"cachedir",   required_argument, 0, OP_CACHEDIR},
+		{"asdeps",     no_argument,       0, OP_ASDEPS},
+		{"logfile",    required_argument, 0, OP_LOGFILE},
+		{"ignoregroup", required_argument, 0, OP_IGNOREGROUP},
+		{"needed",     no_argument,       0, OP_NEEDED},
+		{"asexplicit",     no_argument,   0, OP_ASEXPLICIT},
+		{"arch",       required_argument, 0, OP_ARCH},
+		{"print-format", required_argument, 0, OP_PRINTFORMAT},
+		{0, 0, 0, 0}
+	};
+
+	/* parse operation */
+	while((opt = getopt_long(argc, argv, optstring, opts, &option_index))) {
+		if(opt < 0) {
+			break;
+		} else if(opt == 0) {
+			continue;
+		} else if(opt == '?') {
+			/* unknown option, getopt printed an error */
+			return(1);
+		}
+		parsearg_op(opt, 0);
+	}
+
+	if(config->op == 0) {
+		pm_printf(PM_LOG_ERROR, _("only one operation may be used at a time\n"));
+		return(1);
+	}
+	if(config->help) {
+		usage(config->op, mbasename(argv[0]));
+		return(2);
+	}
+	if(config->version) {
+		version();
+		return(2);
+	}
+
+	/* parse all other options */
+	optind = 1;
+	while((opt = getopt_long(argc, argv, optstring, opts, &option_index))) {
+		if(opt < 0) {
+			break;
+		} else if(opt == 0) {
+			continue;
+		} else if(opt == '?') {
+			/* this should have failed during first pass already */
+			return(1);
+		} else if(parsearg_op(opt, 1) == 0) {
+			/* opt is an operation */
+			continue;
+		}
+
+		switch(config->op) {
+			case PM_OP_DATABASE:
+				result = parsearg_database(opt);
+				break;
+			case PM_OP_QUERY:
+				result = parsearg_query(opt);
+				break;
+			case PM_OP_REMOVE:
+				result = parsearg_remove(opt);
+				break;
+			case PM_OP_SYNC:
+				result = parsearg_sync(opt);
+				break;
+			case PM_OP_UPGRADE:
+				result = parsearg_upgrade(opt);
+				break;
+			case PM_OP_DEPTEST:
+			default:
+				result = 1;
+				break;
+		}
+		if (result == 0) {
+			continue;
+		}
+
+		/* fall back to global options */
+		result = parsearg_global(opt);
+		if(result != 0) {
+			/* global option parsing failed, abort */
+			pm_printf(PM_LOG_ERROR, _("invalid option\n"));
+			return(result);
+		}
+	}
+
+	while(optind < argc) {
+		/* add the target to our target array */
+		pm_targets = alpm_list_add(pm_targets, strdup(argv[optind]));
+		optind++;
+	}
+
+	return(0);
+}
+
+/* helper for being used with setrepeatingoption */
+static void option_add_holdpkg(const char *name) {
+	config->holdpkg = alpm_list_add(config->holdpkg, strdup(name));
+}
+
+/* helper for being used with setrepeatingoption */
+static void option_add_syncfirst(const char *name) {
+	config->syncfirst = alpm_list_add(config->syncfirst, strdup(name));
+}
+
+/* helper for being used with setrepeatingoption */
+static void option_add_cleanmethod(const char *value) {
+	if (strcmp(value, "KeepInstalled") == 0) {
+		config->cleanmethod |= PM_CLEAN_KEEPINST;
+	} else if (strcmp(value, "KeepCurrent") == 0) {
+		config->cleanmethod |= PM_CLEAN_KEEPCUR;
+	} else {
+		pm_printf(PM_LOG_ERROR, _("invalid value for 'CleanMethod' : '%s'\n"),
+				value);
+	}
+}
+
+/** Add repeating options such as NoExtract, NoUpgrade, etc to libalpm
+ * settings. Refactored out of the parseconfig code since all of them did
+ * the exact same thing and duplicated code.
+ * @param ptr a pointer to the start of the multiple options
+ * @param option the string (friendly) name of the option, used for messages
+ * @param optionfunc a function pointer to an alpm_option_add_* function
+ */
+static void setrepeatingoption(char *ptr, const char *option,
+		void (*optionfunc)(const char*))
+{
+	char *q;
+
+	while((q = strchr(ptr, ' '))) {
+		*q = '\0';
+		(*optionfunc)(ptr);
+		pm_printf(PM_LOG_DEBUG, "config: %s: %s\n", option, ptr);
+		ptr = q;
+		ptr++;
+	}
+	(*optionfunc)(ptr);
+	pm_printf(PM_LOG_DEBUG, "config: %s: %s\n", option, ptr);
+}
+
+static char *get_filename(const char *url) {
+	char *filename = strrchr(url, '/');
+	if(filename != NULL) {
+		filename++;
+	}
+	return(filename);
+}
+
+static char *get_destfile(const char *path, const char *filename) {
+	char *destfile;
+	/* len = localpath len + filename len + null */
+	size_t len = strlen(path) + strlen(filename) + 1;
+	destfile = calloc(len, sizeof(char));
+	snprintf(destfile, len, "%s%s", path, filename);
+
+	return(destfile);
+}
+
+static char *get_tempfile(const char *path, const char *filename) {
+	char *tempfile;
+	/* len = localpath len + filename len + '.part' len + null */
+	size_t len = strlen(path) + strlen(filename) + 6;
+	tempfile = calloc(len, sizeof(char));
+	snprintf(tempfile, len, "%s%s.part", path, filename);
+
+	return(tempfile);
+}
+
+/** External fetch callback */
+static int download_with_xfercommand(const char *url, const char *localpath,
+		int force) {
+	int ret = 0;
+	int retval;
+	int usepart = 0;
+	struct stat st;
+	char *parsedcmd,*tempcmd;
+	char cwd[PATH_MAX];
+	int restore_cwd = 0;
+	char *destfile, *tempfile, *filename;
+
+	if(!config->xfercommand) {
+		return -1;
+	}
+
+	filename = get_filename(url);
+	if(!filename) {
+		return -1;
+	}
+	destfile = get_destfile(localpath, filename);
+	tempfile = get_tempfile(localpath, filename);
+
+	if(force && stat(tempfile, &st) == 0) {
+		unlink(tempfile);
+	}
+	if(force && stat(destfile, &st) == 0) {
+		unlink(destfile);
+	}
+
+	tempcmd = strdup(config->xfercommand);
+	/* replace all occurrences of %o with fn.part */
+	if(strstr(tempcmd, "%o")) {
+		usepart = 1;
+		parsedcmd = strreplace(tempcmd, "%o", tempfile);
+		free(tempcmd);
+		tempcmd = parsedcmd;
+	}
+	/* replace all occurrences of %u with the download URL */
+	parsedcmd = strreplace(tempcmd, "%u", url);
+	free(tempcmd);
+
+	/* save the cwd so we can restore it later */
+	if(getcwd(cwd, PATH_MAX) == NULL) {
+		pm_printf(PM_LOG_ERROR, _("could not get current working directory\n"));
+	} else {
+		restore_cwd = 1;
+	}
+
+	/* cwd to the download directory */
+	if(chdir(localpath)) {
+		pm_printf(PM_LOG_WARNING, _("could not chdir to download directory %s\n"), localpath);
+		ret = -1;
+		goto cleanup;
+	}
+	/* execute the parsed command via /bin/sh -c */
+	pm_printf(PM_LOG_DEBUG, "running command: %s\n", parsedcmd);
+	retval = system(parsedcmd);
+
+	if(retval == -1) {
+		pm_printf(PM_LOG_WARNING, _("running XferCommand: fork failed!\n"));
+		ret = -1;
+	} else if(retval != 0) {
+		/* download failed */
+		pm_printf(PM_LOG_DEBUG, "XferCommand command returned non-zero status "
+				"code (%d)\n", retval);
+		ret = -1;
+	} else {
+		/* download was successful */
+		if(usepart) {
+			rename(tempfile, destfile);
+		}
+		ret = 0;
+	}
+
+cleanup:
+	/* restore the old cwd if we have it */
+	if(restore_cwd && chdir(cwd) != 0) {
+		pm_printf(PM_LOG_ERROR, _("could not change directory to %s (%s)\n"), cwd, strerror(errno));
+	}
+
+	if(ret == -1) {
+		/* hack to let an user the time to cancel a download */
+		sleep(2);
+	}
+	free(destfile);
+	free(tempfile);
+	free(parsedcmd);
+
+	return(ret);
+}
+
+static int _parse_options(const char *key, char *value,
+		const char *file, int linenum)
+{
+	if(value == NULL) {
+		/* options without settings */
+		if(strcmp(key, "UseSyslog") == 0) {
+			alpm_option_set_usesyslog(1);
+			pm_printf(PM_LOG_DEBUG, "config: usesyslog\n");
+		} else if(strcmp(key, "ILoveCandy") == 0) {
+			config->chomp = 1;
+			pm_printf(PM_LOG_DEBUG, "config: chomp\n");
+		} else if(strcmp(key, "ShowSize") == 0) {
+			config->showsize = 1;
+			pm_printf(PM_LOG_DEBUG, "config: showsize\n");
+		} else if(strcmp(key, "UseDelta") == 0) {
+			alpm_option_set_usedelta(1);
+			pm_printf(PM_LOG_DEBUG, "config: usedelta\n");
+		} else if(strcmp(key, "TotalDownload") == 0) {
+			config->totaldownload = 1;
+			pm_printf(PM_LOG_DEBUG, "config: totaldownload\n");
+		} else if(strcmp(key, "CheckSpace") == 0) {
+			alpm_option_set_checkspace(1);
+		} else {
+			pm_printf(PM_LOG_WARNING,
+					_("config file %s, line %d: directive '%s' in section '%s' not recognized.\n"),
+					file, linenum, key, "options");
+		}
+	} else {
+		/* options with settings */
+		if(strcmp(key, "NoUpgrade") == 0) {
+			setrepeatingoption(value, "NoUpgrade", alpm_option_add_noupgrade);
+		} else if(strcmp(key, "NoExtract") == 0) {
+			setrepeatingoption(value, "NoExtract", alpm_option_add_noextract);
+		} else if(strcmp(key, "IgnorePkg") == 0) {
+			setrepeatingoption(value, "IgnorePkg", alpm_option_add_ignorepkg);
+		} else if(strcmp(key, "IgnoreGroup") == 0) {
+			setrepeatingoption(value, "IgnoreGroup", alpm_option_add_ignoregrp);
+		} else if(strcmp(key, "HoldPkg") == 0) {
+			setrepeatingoption(value, "HoldPkg", option_add_holdpkg);
+		} else if(strcmp(key, "SyncFirst") == 0) {
+			setrepeatingoption(value, "SyncFirst", option_add_syncfirst);
+		} else if(strcmp(key, "Architecture") == 0) {
+			if(!alpm_option_get_arch()) {
+				setarch(value);
+			}
+		} else if(strcmp(key, "DBPath") == 0) {
+			/* don't overwrite a path specified on the command line */
+			if(!config->dbpath) {
+				config->dbpath = strdup(value);
+				pm_printf(PM_LOG_DEBUG, "config: dbpath: %s\n", value);
+			}
+		} else if(strcmp(key, "CacheDir") == 0) {
+			if(alpm_option_add_cachedir(value) != 0) {
+				pm_printf(PM_LOG_ERROR, _("problem adding cachedir '%s' (%s)\n"),
+						value, alpm_strerrorlast());
+				return(1);
+			}
+			pm_printf(PM_LOG_DEBUG, "config: cachedir: %s\n", value);
+		} else if(strcmp(key, "RootDir") == 0) {
+			/* don't overwrite a path specified on the command line */
+			if(!config->rootdir) {
+				config->rootdir = strdup(value);
+				pm_printf(PM_LOG_DEBUG, "config: rootdir: %s\n", value);
+			}
+		} else if (strcmp(key, "LogFile") == 0) {
+			if(!config->logfile) {
+				config->logfile = strdup(value);
+				pm_printf(PM_LOG_DEBUG, "config: logfile: %s\n", value);
+			}
+		} else if (strcmp(key, "XferCommand") == 0) {
+			config->xfercommand = strdup(value);
+			alpm_option_set_fetchcb(download_with_xfercommand);
+			pm_printf(PM_LOG_DEBUG, "config: xfercommand: %s\n", value);
+		} else if (strcmp(key, "CleanMethod") == 0) {
+			setrepeatingoption(value, "CleanMethod", option_add_cleanmethod);
+		} else {
+
+			pm_printf(PM_LOG_WARNING,
+					_("config file %s, line %d: directive '%s' in section '%s' not recognized.\n"),
+					file, linenum, key, "options");
+		}
+
+	}
+	return(0);
+}
+
+static int _add_mirror(pmdb_t *db, char *value)
+{
+	const char *dbname = alpm_db_get_name(db);
+	/* let's attempt a replacement for the current repo */
+	char *temp = strreplace(value, "$repo", dbname);
+	/* let's attempt a replacement for the arch */
+	const char *arch = alpm_option_get_arch();
+	char *server;
+	if(arch) {
+		server = strreplace(temp, "$arch", arch);
+		free(temp);
+	} else {
+		if(strstr(temp, "$arch")) {
+			free(temp);
+			pm_printf(PM_LOG_ERROR, _("The mirror '%s' contains the $arch"
+						" variable, but no Architecture is defined.\n"), value);
+			return(1);
+		}
+		server = temp;
+	}
+
+	if(alpm_db_setserver(db, server) != 0) {
+		/* pm_errno is set by alpm_db_setserver */
+		pm_printf(PM_LOG_ERROR, _("could not add server URL to database '%s': %s (%s)\n"),
+				dbname, server, alpm_strerrorlast());
+		free(server);
+		return(1);
+	}
+
+	free(server);
+	return(0);
+}
+
+/* The real parseconfig. Called with a null section argument by the publicly
+ * visible parseconfig so we can recall from within ourself on an include */
+static int _parseconfig(const char *file, const char *givensection,
+                        pmdb_t * const givendb)
+{
+	FILE *fp = NULL;
+	char line[PATH_MAX+1];
+	int linenum = 0;
+	char *ptr, *section = NULL;
+	pmdb_t *db = NULL;
+	int ret = 0;
+
+	pm_printf(PM_LOG_DEBUG, "config: attempting to read file %s\n", file);
+	fp = fopen(file, "r");
+	if(fp == NULL) {
+		pm_printf(PM_LOG_ERROR, _("config file %s could not be read.\n"), file);
+		return(1);
+	}
+
+	/* if we are passed a section, use it as our starting point */
+	if(givensection != NULL) {
+		section = strdup(givensection);
+	}
+	/* if we are passed a db, use it as our starting point */
+	if(givendb != NULL) {
+		db = givendb;
+	}
+
+	while(fgets(line, PATH_MAX, fp)) {
+		linenum++;
+		strtrim(line);
+
+		/* ignore whole line and end of line comments */
+		if(strlen(line) == 0 || line[0] == '#') {
+			continue;
+		}
+		if((ptr = strchr(line, '#'))) {
+			*ptr = '\0';
+		}
+
+		if(line[0] == '[' && line[strlen(line)-1] == ']') {
+			/* new config section, skip the '[' */
+			ptr = line;
+			ptr++;
+			if(section) {
+				free(section);
+			}
+			section = strdup(ptr);
+			section[strlen(section)-1] = '\0';
+			pm_printf(PM_LOG_DEBUG, "config: new section '%s'\n", section);
+			if(!strlen(section)) {
+				pm_printf(PM_LOG_ERROR, _("config file %s, line %d: bad section name.\n"),
+						file, linenum);
+				ret = 1;
+				goto cleanup;
+			}
+			/* if we are not looking at the options section, register a db */
+			if(strcmp(section, "options") != 0) {
+				db = alpm_db_register_sync(section);
+				if(db == NULL) {
+					pm_printf(PM_LOG_ERROR, _("could not register '%s' database (%s)\n"),
+							section, alpm_strerrorlast());
+					ret = 1;
+					goto cleanup;
+				}
+			}
+			continue;
+		}
+
+		/* directive */
+		char *key, *value;
+		/* strsep modifies the 'line' string: 'key \0 value' */
+		key = line;
+		value = line;
+		strsep(&value, "=");
+		strtrim(key);
+		strtrim(value);
+
+		if(key == NULL) {
+			pm_printf(PM_LOG_ERROR, _("config file %s, line %d: syntax error in config file- missing key.\n"),
+					file, linenum);
+			ret = 1;
+			goto cleanup;
+		}
+		/* For each directive, compare to the camelcase string. */
+		if(section == NULL) {
+			pm_printf(PM_LOG_ERROR, _("config file %s, line %d: All directives must belong to a section.\n"),
+					file, linenum);
+			ret = 1;
+			goto cleanup;
+		}
+		/* Include is allowed in both options and repo sections */
+		if(strcmp(key, "Include") == 0) {
+			if(value == NULL) {
+				pm_printf(PM_LOG_ERROR, _("config file %s, line %d: directive '%s' needs a value\n"),
+						file, linenum, key);
+				ret = 1;
+				goto cleanup;
+			}
+			/* Ignore include failures... assume non-critical */
+			int globret;
+			glob_t globbuf;
+			globret = glob(value, GLOB_NOCHECK, NULL, &globbuf);
+			switch(globret) {
+				case GLOB_NOSPACE:
+					pm_printf(PM_LOG_DEBUG,
+							"config file %s, line %d: include globbing out of space\n",
+							file, linenum);
+				break;
+				case GLOB_ABORTED:
+					pm_printf(PM_LOG_DEBUG,
+							"config file %s, line %d: include globbing read error for %s\n",
+							file, linenum, value);
+				break;
+				case GLOB_NOMATCH:
+					pm_printf(PM_LOG_DEBUG,
+							"config file %s, line %d: no include found for %s\n",
+							file, linenum, value);
+				break;
+				default:
+					for(size_t gindex = 0; gindex < globbuf.gl_pathc; gindex++) {
+						pm_printf(PM_LOG_DEBUG, "config file %s, line %d: including %s\n",
+								file, linenum, globbuf.gl_pathv[gindex]);
+						_parseconfig(globbuf.gl_pathv[gindex], section, db);
+					}
+				break;
+			}
+			globfree(&globbuf);
+			continue;
+		}
+		if(strcmp(section, "options") == 0) {
+			/* we are either in options ... */
+			if((ret = _parse_options(key, value, file, linenum)) != 0) {
+				goto cleanup;
+			}
+		} else {
+			/* ... or in a repo section */
+			if(strcmp(key, "Server") == 0) {
+				if(value == NULL) {
+					pm_printf(PM_LOG_ERROR, _("config file %s, line %d: directive '%s' needs a value\n"),
+							file, linenum, key);
+					ret = 1;
+					goto cleanup;
+				}
+				if(_add_mirror(db, value) != 0) {
+					ret = 1;
+					goto cleanup;
+				}
+			} else {
+				pm_printf(PM_LOG_WARNING,
+						_("config file %s, line %d: directive '%s' in section '%s' not recognized.\n"),
+						file, linenum, key, section);
+			}
+		}
+
+	}
+
+cleanup:
+	fclose(fp);
+	if(section){
+		free(section);
+	}
+	/* call setlibpaths here to ensure we have called it at least once */
+	setlibpaths();
+	pm_printf(PM_LOG_DEBUG, "config: finished parsing %s\n", file);
+	return(ret);
+}
+
+/** Parse a configuration file.
+ * @param file path to the config file.
+ * @return 0 on success, non-zero on error
+ */
+static int parseconfig(const char *file)
+{
+	/* call the real parseconfig function with a null section & db argument */
+	return(_parseconfig(file, NULL, NULL));
+}
+
+/** print commandline to logfile
+ */
+static void cl_to_log(int argc, char* argv[])
+{
+	size_t size = 0;
+	int i;
+	for(i = 0; i<argc; i++) {
+		size += strlen(argv[i]) + 1;
+	}
+	char *cl_text = malloc(size);
+	if(!cl_text)
+		return;
+	char *p = cl_text;
+	for(i = 0; i<argc-1; i++) {
+		strcpy(p, argv[i]);
+		p += strlen(argv[i]);
+		*p++ = ' ';
+	}
+	strcpy(p, argv[i]);
+	alpm_logaction("Running '%s'\n", cl_text);
+	free(cl_text);
+}
+
+/** Main function.
+ * @param argc argc
+ * @param argv argv
+ * @return A return code indicating success, failure, etc.
+ */
+int main(int argc, char *argv[])
+{
+	int ret = 0;
+	struct sigaction new_action, old_action;
+#if defined(HAVE_GETEUID) && !defined(CYGWIN)
+	/* geteuid undefined in CYGWIN */
+	uid_t myuid = geteuid();
+#endif
+
+#if defined(PACMAN_DEBUG) && defined(HAVE_MCHECK_H)
+	/*setenv("MALLOC_TRACE","pacman.mtrace", 0);*/
+	mtrace();
+#endif
+
+	/* Set signal handlers */
+	/* Set up the structure to specify the new action. */
+	new_action.sa_handler = handler;
+	sigemptyset(&new_action.sa_mask);
+	new_action.sa_flags = 0;
+
+	sigaction(SIGINT, NULL, &old_action);
+	if(old_action.sa_handler != SIG_IGN) {
+		sigaction(SIGINT, &new_action, NULL);
+	}
+	sigaction(SIGTERM, NULL, &old_action);
+	if(old_action.sa_handler != SIG_IGN) {
+		sigaction(SIGTERM, &new_action, NULL);
+	}
+	sigaction(SIGSEGV, NULL, &old_action);
+	if(old_action.sa_handler != SIG_IGN) {
+		sigaction(SIGSEGV, &new_action, NULL);
+	}
+
+	/* i18n init */
+#if defined(ENABLE_NLS)
+	localize();
+#endif
+
+	/* set user agent for downloading */
+	setuseragent();
+
+	/* init config data */
+	config = config_new();
+
+	/* disable progressbar if the output is redirected */
+	if(!isatty(1)) {
+		config->noprogressbar = 1;
+	}
+
+	/* initialize library */
+	if(alpm_initialize() == -1) {
+		pm_printf(PM_LOG_ERROR, _("failed to initialize alpm library (%s)\n"),
+		        alpm_strerrorlast());
+		cleanup(EXIT_FAILURE);
+	}
+
+	/* Setup logging as soon as possible, to print out maximum debugging info */
+	alpm_option_set_logcb(cb_log);
+	alpm_option_set_dlcb(cb_dl_progress);
+	/* define paths to reasonable defaults */
+	alpm_option_set_root(ROOTDIR);
+	alpm_option_set_dbpath(DBPATH);
+	alpm_option_set_logfile(LOGFILE);
+
+	/* Priority of options:
+	 * 1. command line
+	 * 2. config file
+	 * 3. compiled-in defaults
+	 * However, we have to parse the command line first because a config file
+	 * location can be specified here, so we need to make sure we prefer these
+	 * options over the config file coming second.
+	 */
+
+	/* parse the command line */
+	ret = parseargs(argc, argv);
+	if(ret != 0) {
+		cleanup(ret);
+	}
+
+	/* we support reading targets from stdin if a cmdline parameter is '-' */
+	if(!isatty(fileno(stdin)) && alpm_list_find_str(pm_targets, "-")) {
+		char line[PATH_MAX];
+		int i = 0;
+
+		/* remove the '-' from the list */
+		pm_targets = alpm_list_remove_str(pm_targets, "-", NULL);
+
+		while(i < PATH_MAX && (line[i] = (char)fgetc(stdin)) != EOF) {
+			if(isspace((unsigned char)line[i])) {
+				/* avoid adding zero length arg when multiple spaces separate args */
+				if(i > 0) {
+					line[i] = '\0';
+					pm_targets = alpm_list_add(pm_targets, strdup(line));
+					i = 0;
+				}
+			} else {
+				i++;
+			}
+		}
+		/* check for buffer overflow */
+		if (i >= PATH_MAX) {
+			pm_printf(PM_LOG_ERROR, _("buffer overflow detected in arg parsing\n"));
+			cleanup(EXIT_FAILURE);
+		}
+
+		/* end of stream -- check for data still in line buffer */
+		if(i > 0) {
+			line[i] = '\0';
+			pm_targets = alpm_list_add(pm_targets, strdup(line));
+		}
+		if (!freopen(ctermid(NULL), "r", stdin)) {
+			pm_printf(PM_LOG_ERROR, _("failed to reopen stdin for reading: (%s)\n"),
+					strerror(errno));
+		}
+	}
+
+	/* parse the config file */
+	ret = parseconfig(config->configfile);
+	if(ret != 0) {
+		cleanup(ret);
+	}
+
+	/* set TotalDownload callback if option enabled */
+	if(config->totaldownload) {
+		alpm_option_set_totaldlcb(cb_dl_total);
+	}
+
+	/* noask is meant to be non-interactive */
+	if(config->noask) {
+		config->noconfirm = 1;
+	}
+
+	/* set up the print operations */
+	if(config->print) {
+		config->noconfirm = 1;
+		config->flags |= PM_TRANS_FLAG_NOCONFLICTS;
+		config->flags |= PM_TRANS_FLAG_NOLOCK;
+		/* Display only errors */
+		config->logmask &= ~PM_LOG_WARNING;
+	}
+
+#if defined(HAVE_GETEUID) && !defined(CYGWIN)
+	/* check if we have sufficient permission for the requested operation */
+	if(myuid > 0 && needs_root()) {
+		pm_printf(PM_LOG_ERROR, _("you cannot perform this operation unless you are root.\n"));
+		cleanup(EXIT_FAILURE);
+	}
+#endif
+
+	if(config->verbose > 0) {
+		alpm_list_t *i;
+		printf("Root      : %s\n", alpm_option_get_root());
+		printf("Conf File : %s\n", config->configfile);
+		printf("DB Path   : %s\n", alpm_option_get_dbpath());
+		printf("Cache Dirs: ");
+		for(i = alpm_option_get_cachedirs(); i; i = alpm_list_next(i)) {
+			printf("%s  ", (char*)alpm_list_getdata(i));
+		}
+		printf("\n");
+		printf("Lock File : %s\n", alpm_option_get_lockfile());
+		printf("Log File  : %s\n", alpm_option_get_logfile());
+		list_display("Targets   :", pm_targets);
+	}
+
+	/* Log commandline */
+	if(needs_root()) {
+		cl_to_log(argc, argv);
+	}
+
+	/* start the requested operation */
+	switch(config->op) {
+		case PM_OP_DATABASE:
+			ret = pacman_database(pm_targets);
+			break;
+		case PM_OP_REMOVE:
+			ret = pacman_remove(pm_targets);
+			break;
+		case PM_OP_UPGRADE:
+			ret = pacman_upgrade(pm_targets);
+			break;
+		case PM_OP_QUERY:
+			ret = pacman_query(pm_targets);
+			break;
+		case PM_OP_SYNC:
+			ret = pacman_sync(pm_targets);
+			break;
+		case PM_OP_DEPTEST:
+			ret = pacman_deptest(pm_targets);
+			break;
+		default:
+			pm_printf(PM_LOG_ERROR, _("no operation specified (use -h for help)\n"));
+			ret = EXIT_FAILURE;
+	}
+
+	cleanup(ret);
+	/* not reached */
+	return(EXIT_SUCCESS);
+}
+
+/* vim: set ts=2 sw=2 noet: */
diff -Naur pacman-3.5.2//src/pacman/query.c pacman-color-3.5.2//src/pacman/query.c
--- pacman-3.5.2//src/pacman/query.c	2011-04-18 18:10:53.000000000 +0200
+++ pacman-color-3.5.2//src/pacman/query.c	2011-04-19 17:21:28.000000000 +0200
@@ -256,7 +256,9 @@
 		pmpkg_t *pkg = alpm_list_getdata(i);
 
 		if (!config->quiet) {
-			printf("local/%s %s", alpm_pkg_get_name(pkg), alpm_pkg_get_version(pkg));
+			color_printf(COLOR_MAGENTA_ALL, "local/");
+			color_printf(COLOR_WHITE_ALL, "%s ", alpm_pkg_get_name(pkg));
+			color_printf(COLOR_GREEN_ALL, "%s", alpm_pkg_get_version(pkg));
 		} else {
 			printf("%s", alpm_pkg_get_name(pkg));
 		}
@@ -273,16 +275,11 @@
 		if (!config->quiet) {
 			if((grp = alpm_pkg_get_groups(pkg)) != NULL) {
 				alpm_list_t *k;
-				printf(" (");
+				color_printf(COLOR_BLUE_ALL, " (");
 				for(k = grp; k; k = alpm_list_next(k)) {
 					const char *group = alpm_list_getdata(k);
-					printf("%s", group);
-					if(alpm_list_next(k)) {
-						/* only print a spacer if there are more groups */
-						printf(" ");
-					}
+					color_printf(COLOR_BLUE_ALL, "%s%s", group, (alpm_list_next(k) ? " " : ")"));
 				}
-				printf(")");
 			}
 
 			/* we need a newline and initial indent first */
@@ -316,7 +313,8 @@
 			packages = alpm_grp_get_pkgs(grp);
 
 			for(p = packages; p; p = alpm_list_next(p)) {
-				printf("%s %s\n", grpname, alpm_pkg_get_name(alpm_list_getdata(p)));
+				color_printf(COLOR_BLUE_ALL, "%s ", grpname);
+				color_printf(COLOR_WHITE_ALL, "%s\n", alpm_pkg_get_name(alpm_list_getdata(p)));
 			}
 		}
 	} else {
@@ -328,8 +326,8 @@
 				const alpm_list_t *p, *packages = alpm_grp_get_pkgs(grp);
 				for(p = packages; p; p = alpm_list_next(p)) {
 					if(!config->quiet) {
-						printf("%s %s\n", grpname,
-								alpm_pkg_get_name(alpm_list_getdata(p)));
+						color_printf(COLOR_BLUE_ALL, "%s ", grpname);
+						color_printf(COLOR_WHITE_ALL, "%s\n", alpm_pkg_get_name(alpm_list_getdata(p)));
 					} else {
 						printf("%s\n", alpm_pkg_get_name(alpm_list_getdata(p)));
 					}
@@ -477,7 +475,8 @@
 	if(!config->op_q_info && !config->op_q_list
 			&& !config->op_q_changelog && !config->op_q_check) {
 		if (!config->quiet) {
-			printf("%s %s\n", alpm_pkg_get_name(pkg), alpm_pkg_get_version(pkg));
+			color_printf(COLOR_WHITE_ALL, "%s ", alpm_pkg_get_name(pkg));
+			color_printf(COLOR_GREEN_ALL, "%s\n", alpm_pkg_get_version(pkg));
 		} else {
 			printf("%s\n", alpm_pkg_get_name(pkg));
 		}
diff -Naur pacman-3.5.2//src/pacman/query.c.orig pacman-color-3.5.2//src/pacman/query.c.orig
--- pacman-3.5.2//src/pacman/query.c.orig	1970-01-01 01:00:00.000000000 +0100
+++ pacman-color-3.5.2//src/pacman/query.c.orig	2011-04-18 18:10:53.000000000 +0200
@@ -0,0 +1,592 @@
+/*
+ *  query.c
+ *
+ *  Copyright (c) 2006-2011 Pacman Development Team <pacman-dev@archlinux.org>
+ *  Copyright (c) 2002-2006 by Judd Vinet <jvinet@zeroflux.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "config.h"
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <limits.h>
+#include <string.h>
+#include <sys/stat.h>
+#include <errno.h>
+#include <unistd.h>
+
+#include <alpm.h>
+#include <alpm_list.h>
+
+/* pacman */
+#include "pacman.h"
+#include "package.h"
+#include "conf.h"
+#include "util.h"
+
+static char *resolve_path(const char *file)
+{
+	char *str = NULL;
+
+	str = calloc(PATH_MAX + 1, sizeof(char));
+	if(!str) {
+		return(NULL);
+	}
+
+	if(!realpath(file, str)) {
+		free(str);
+		return(NULL);
+	}
+
+	return(str);
+}
+
+/* check if filename exists in PATH */
+static int search_path(char **filename, struct stat *bufptr)
+{
+	char *envpath, *envpathsplit, *path, *fullname;
+	size_t flen;
+
+	if ((envpath = getenv("PATH")) == NULL) {
+		return(-1);
+	}
+	if ((envpath = envpathsplit = strdup(envpath)) == NULL) {
+		return(-1);
+	}
+
+	flen = strlen(*filename);
+
+	while ((path = strsep(&envpathsplit, ":")) != NULL) {
+		size_t plen = strlen(path);
+
+		/* strip the trailing slash if one exists */
+		while(path[plen - 1] == '/') {
+				path[--plen] = '\0';
+		}
+
+		fullname = malloc(plen + flen + 2);
+		sprintf(fullname, "%s/%s", path, *filename);
+
+		if(lstat(fullname, bufptr) == 0) {
+			free(*filename);
+			*filename = fullname;
+			free(envpath);
+			return(0);
+		}
+		free(fullname);
+	}
+	free(envpath);
+	return(-1);
+}
+
+static void print_query_fileowner(const char *filename, pmpkg_t *info)
+{
+	if (!config->quiet) {
+		printf(_("%s is owned by %s %s\n"), filename,
+				alpm_pkg_get_name(info), alpm_pkg_get_version(info));
+	} else {
+		printf("%s\n", alpm_pkg_get_name(info));
+	}
+}
+
+static int query_fileowner(alpm_list_t *targets)
+{
+	int ret = 0;
+	char path[PATH_MAX];
+	const char *root;
+	char *append;
+	size_t max_length;
+	alpm_list_t *t;
+	pmdb_t *db_local;
+
+	/* This code is here for safety only */
+	if(targets == NULL) {
+		pm_fprintf(stderr, PM_LOG_ERROR, _("no file was specified for --owns\n"));
+		return(1);
+	}
+
+	/* Set up our root path buffer. We only need to copy the location of root in
+	 * once, then we can just overwrite whatever file was there on the previous
+	 * iteration. */
+	root = alpm_option_get_root();
+	strncpy(path, root, PATH_MAX - 1);
+	append = path + strlen(path);
+	max_length = PATH_MAX - (append - path) - 1;
+
+	db_local = alpm_option_get_localdb();
+
+	for(t = targets; t; t = alpm_list_next(t)) {
+		char *filename, *dname, *rpath;
+		const char *bname;
+		struct stat buf;
+		alpm_list_t *i;
+		int found = 0;
+
+		filename = strdup(alpm_list_getdata(t));
+
+		if(lstat(filename, &buf) == -1) {
+			/*  if it is not a path but a program name, then check in PATH */
+			if(strchr(filename, '/') == NULL) {
+				if(search_path(&filename, &buf) == -1) {
+					pm_fprintf(stderr, PM_LOG_ERROR, _("failed to find '%s' in PATH: %s\n"),
+							filename, strerror(errno));
+					ret++;
+					free(filename);
+					continue;
+				}
+			} else {
+				pm_fprintf(stderr, PM_LOG_ERROR, _("failed to read file '%s': %s\n"),
+						filename, strerror(errno));
+				ret++;
+				free(filename);
+				continue;
+			}
+		}
+
+		if(S_ISDIR(buf.st_mode)) {
+			pm_fprintf(stderr, PM_LOG_ERROR,
+				_("cannot determine ownership of directory '%s'\n"), filename);
+			ret++;
+			free(filename);
+			continue;
+		}
+
+		bname = mbasename(filename);
+		dname = mdirname(filename);
+		/* for files in '/', there is no directory name to match */
+		if (strcmp(dname, "") == 0) {
+			rpath = NULL;
+		} else {
+			rpath = resolve_path(dname);
+
+			if(!rpath) {
+				pm_fprintf(stderr, PM_LOG_ERROR, _("cannot determine real path for '%s': %s\n"),
+						filename, strerror(errno));
+				free(filename);
+				free(dname);
+				free(rpath);
+				ret++;
+				continue;
+			}
+		}
+		free(dname);
+
+		for(i = alpm_db_get_pkgcache(db_local); i && !found; i = alpm_list_next(i)) {
+			alpm_list_t *j;
+			pmpkg_t *info = alpm_list_getdata(i);
+
+			for(j = alpm_pkg_get_files(info); j && !found; j = alpm_list_next(j)) {
+				char *ppath, *pdname;
+				const char *pkgfile = alpm_list_getdata(j);
+
+				/* avoid the costly resolve_path usage if the basenames don't match */
+				if(strcmp(mbasename(pkgfile), bname) != 0) {
+					continue;
+				}
+
+				/* for files in '/', there is no directory name to match */
+				if(!rpath) {
+					print_query_fileowner(filename, info);
+					found = 1;
+					continue;
+				}
+
+				if(strlen(pkgfile) > max_length) {
+					pm_fprintf(stderr, PM_LOG_ERROR, _("path too long: %s%s\n"), root, pkgfile);
+				}
+				/* concatenate our file and the root path */
+				strcpy(append, pkgfile);
+
+				pdname = mdirname(path);
+				ppath = resolve_path(pdname);
+				free(pdname);
+
+				if(ppath && strcmp(ppath, rpath) == 0) {
+					print_query_fileowner(filename, info);
+					found = 1;
+				}
+				free(ppath);
+			}
+		}
+		if(!found) {
+			pm_fprintf(stderr, PM_LOG_ERROR, _("No package owns %s\n"), filename);
+			ret++;
+		}
+		free(filename);
+		free(rpath);
+	}
+
+	return ret;
+}
+
+/* search the local database for a matching package */
+static int query_search(alpm_list_t *targets)
+{
+	alpm_list_t *i, *searchlist;
+	int freelist;
+	pmdb_t *db_local = alpm_option_get_localdb();
+
+	/* if we have a targets list, search for packages matching it */
+	if(targets) {
+		searchlist = alpm_db_search(db_local, targets);
+		freelist = 1;
+	} else {
+		searchlist = alpm_db_get_pkgcache(db_local);
+		freelist = 0;
+	}
+	if(searchlist == NULL) {
+		return(1);
+	}
+
+	for(i = searchlist; i; i = alpm_list_next(i)) {
+		alpm_list_t *grp;
+		pmpkg_t *pkg = alpm_list_getdata(i);
+
+		if (!config->quiet) {
+			printf("local/%s %s", alpm_pkg_get_name(pkg), alpm_pkg_get_version(pkg));
+		} else {
+			printf("%s", alpm_pkg_get_name(pkg));
+		}
+
+		/* print the package size with the output if ShowSize option set */
+		if(!config->quiet && config->showsize) {
+			/* Convert byte size to MB */
+			double mbsize = (double)alpm_pkg_get_size(pkg) / (1024.0 * 1024.0);
+
+			printf(" [%.2f MB]", mbsize);
+		}
+
+
+		if (!config->quiet) {
+			if((grp = alpm_pkg_get_groups(pkg)) != NULL) {
+				alpm_list_t *k;
+				printf(" (");
+				for(k = grp; k; k = alpm_list_next(k)) {
+					const char *group = alpm_list_getdata(k);
+					printf("%s", group);
+					if(alpm_list_next(k)) {
+						/* only print a spacer if there are more groups */
+						printf(" ");
+					}
+				}
+				printf(")");
+			}
+
+			/* we need a newline and initial indent first */
+			printf("\n    ");
+			indentprint(alpm_pkg_get_desc(pkg), 4);
+		}
+		printf("\n");
+	}
+
+	/* we only want to free if the list was a search list */
+	if(freelist) {
+		alpm_list_free(searchlist);
+	}
+	return(0);
+}
+
+static int query_group(alpm_list_t *targets)
+{
+	alpm_list_t *i, *j;
+	char *grpname = NULL;
+	int ret = 0;
+	pmdb_t *db_local = alpm_option_get_localdb();
+
+	if(targets == NULL) {
+		for(j = alpm_db_get_grpcache(db_local); j; j = alpm_list_next(j)) {
+			pmgrp_t *grp = alpm_list_getdata(j);
+			const alpm_list_t *p, *packages;
+			const char *grpname;
+
+			grpname = alpm_grp_get_name(grp);
+			packages = alpm_grp_get_pkgs(grp);
+
+			for(p = packages; p; p = alpm_list_next(p)) {
+				printf("%s %s\n", grpname, alpm_pkg_get_name(alpm_list_getdata(p)));
+			}
+		}
+	} else {
+		for(i = targets; i; i = alpm_list_next(i)) {
+			pmgrp_t *grp;
+			grpname = alpm_list_getdata(i);
+			grp = alpm_db_readgrp(db_local, grpname);
+			if(grp) {
+				const alpm_list_t *p, *packages = alpm_grp_get_pkgs(grp);
+				for(p = packages; p; p = alpm_list_next(p)) {
+					if(!config->quiet) {
+						printf("%s %s\n", grpname,
+								alpm_pkg_get_name(alpm_list_getdata(p)));
+					} else {
+						printf("%s\n", alpm_pkg_get_name(alpm_list_getdata(p)));
+					}
+				}
+			} else {
+				pm_fprintf(stderr, PM_LOG_ERROR, _("group \"%s\" was not found\n"), grpname);
+				ret++;
+			}
+		}
+	}
+	return ret;
+}
+
+static int is_foreign(pmpkg_t *pkg)
+{
+	const char *pkgname = alpm_pkg_get_name(pkg);
+	alpm_list_t *j;
+	alpm_list_t *sync_dbs = alpm_option_get_syncdbs();
+
+	int match = 0;
+	for(j = sync_dbs; j; j = alpm_list_next(j)) {
+		pmdb_t *db = alpm_list_getdata(j);
+		pmpkg_t *findpkg = alpm_db_get_pkg(db, pkgname);
+		if(findpkg) {
+			match = 1;
+			break;
+		}
+	}
+	if(match == 0) {
+		return(1);
+	}
+	return(0);
+}
+
+static int is_unrequired(pmpkg_t *pkg)
+{
+	alpm_list_t *requiredby = alpm_pkg_compute_requiredby(pkg);
+	if(requiredby == NULL) {
+		return(1);
+	}
+	FREELIST(requiredby);
+	return(0);
+}
+
+static int filter(pmpkg_t *pkg)
+{
+	/* check if this package was explicitly installed */
+	if(config->op_q_explicit &&
+			alpm_pkg_get_reason(pkg) != PM_PKG_REASON_EXPLICIT) {
+		return(0);
+	}
+	/* check if this package was installed as a dependency */
+	if(config->op_q_deps &&
+			alpm_pkg_get_reason(pkg) != PM_PKG_REASON_DEPEND) {
+		return(0);
+	}
+	/* check if this pkg isn't in a sync DB */
+	if(config->op_q_foreign && !is_foreign(pkg)) {
+		return(0);
+	}
+	/* check if this pkg is unrequired */
+	if(config->op_q_unrequired && !is_unrequired(pkg)) {
+		return(0);
+	}
+	/* check if this pkg is outdated */
+	if(config->op_q_upgrade && (alpm_sync_newversion(pkg, alpm_option_get_syncdbs()) == NULL)) {
+		return(0);
+	}
+	return(1);
+}
+
+/* Loop through the packages. For each package,
+ * loop through files to check if they exist. */
+static int check(pmpkg_t *pkg)
+{
+	alpm_list_t *i;
+	const char *root;
+	int allfiles = 0, errors = 0;
+	size_t rootlen;
+	char f[PATH_MAX];
+
+	root = alpm_option_get_root();
+	rootlen = strlen(root);
+	if(rootlen + 1 > PATH_MAX) {
+		/* we are in trouble here */
+		pm_fprintf(stderr, PM_LOG_ERROR, _("path too long: %s%s\n"), root, "");
+		return(1);
+	}
+	strcpy(f, root);
+
+	const char *pkgname = alpm_pkg_get_name(pkg);
+	for(i = alpm_pkg_get_files(pkg); i; i = alpm_list_next(i)) {
+		struct stat st;
+		const char *path = alpm_list_getdata(i);
+
+		if(rootlen + 1 + strlen(path) > PATH_MAX) {
+			pm_fprintf(stderr, PM_LOG_WARNING, _("path too long: %s%s\n"), root, path);
+			continue;
+		}
+		strcpy(f + rootlen, path);
+		allfiles++;
+		/* use lstat to prevent errors from symlinks */
+		if(lstat(f, &st) != 0) {
+			if(config->quiet) {
+				printf("%s %s\n", pkgname, f);
+			} else {
+				pm_printf(PM_LOG_WARNING, "%s: %s (%s)\n",
+						pkgname, f, strerror(errno));
+			}
+			errors++;
+		}
+	}
+
+	if(!config->quiet) {
+		printf(_n("%s: %d total file, ", "%s: %d total files, ",
+					(unsigned long)allfiles), pkgname, allfiles);
+		printf(_n("%d missing file\n", "%d missing files\n",
+					(unsigned long)errors), errors);
+	}
+
+	return(errors != 0 ? 1 : 0);
+}
+
+static int display(pmpkg_t *pkg)
+{
+	int ret = 0;
+
+	if(config->op_q_info) {
+		if(config->op_q_isfile) {
+			/* omit info that isn't applicable for a file package */
+			dump_pkg_full(pkg, 0);
+		} else {
+			dump_pkg_full(pkg, config->op_q_info);
+		}
+	}
+	if(config->op_q_list) {
+		dump_pkg_files(pkg, config->quiet);
+	}
+	if(config->op_q_changelog) {
+		dump_pkg_changelog(pkg);
+	}
+	if(config->op_q_check) {
+		ret = check(pkg);
+	}
+	if(!config->op_q_info && !config->op_q_list
+			&& !config->op_q_changelog && !config->op_q_check) {
+		if (!config->quiet) {
+			printf("%s %s\n", alpm_pkg_get_name(pkg), alpm_pkg_get_version(pkg));
+		} else {
+			printf("%s\n", alpm_pkg_get_name(pkg));
+		}
+	}
+	return(ret);
+}
+
+int pacman_query(alpm_list_t *targets)
+{
+	int ret = 0;
+	int match = 0;
+	alpm_list_t *i;
+	pmpkg_t *pkg = NULL;
+	pmdb_t *db_local;
+
+	/* First: operations that do not require targets */
+
+	/* search for a package */
+	if(config->op_q_search) {
+		ret = query_search(targets);
+		return(ret);
+	}
+
+	/* looking for groups */
+	if(config->group) {
+		ret = query_group(targets);
+		return(ret);
+	}
+
+	if(config->op_q_foreign) {
+		/* ensure we have at least one valid sync db set up */
+		alpm_list_t *sync_dbs = alpm_option_get_syncdbs();
+		if(sync_dbs == NULL || alpm_list_count(sync_dbs) == 0) {
+			pm_printf(PM_LOG_ERROR, _("no usable package repositories configured.\n"));
+			return(1);
+		}
+	}
+
+	db_local = alpm_option_get_localdb();
+
+	/* operations on all packages in the local DB
+	 * valid: no-op (plain -Q), list, info, check
+	 * invalid: isfile, owns */
+	if(targets == NULL) {
+		if(config->op_q_isfile || config->op_q_owns) {
+			pm_printf(PM_LOG_ERROR, _("no targets specified (use -h for help)\n"));
+			return(1);
+		}
+
+		for(i = alpm_db_get_pkgcache(db_local); i; i = alpm_list_next(i)) {
+			pkg = alpm_list_getdata(i);
+			if(filter(pkg)) {
+				int value = display(pkg);
+				if(value != 0) {
+					ret = 1;
+				}
+				match = 1;
+			}
+		}
+		if(!match) {
+			ret = 1;
+		}
+		return(ret);
+	}
+
+	/* Second: operations that require target(s) */
+
+	/* determine the owner of a file */
+	if(config->op_q_owns) {
+		ret = query_fileowner(targets);
+		return(ret);
+	}
+
+	/* operations on named packages in the local DB
+	 * valid: no-op (plain -Q), list, info, check */
+	for(i = targets; i; i = alpm_list_next(i)) {
+		char *strname = alpm_list_getdata(i);
+
+		if(config->op_q_isfile) {
+			alpm_pkg_load(strname, 1, &pkg);
+		} else {
+			pkg = alpm_db_get_pkg(db_local, strname);
+		}
+
+		if(pkg == NULL) {
+			pm_fprintf(stderr, PM_LOG_ERROR, _("package \"%s\" not found\n"), strname);
+			ret = 1;
+			continue;
+		}
+
+		if(filter(pkg)) {
+			int value = display(pkg);
+			if(value != 0) {
+				ret = 1;
+			}
+			match = 1;
+		}
+
+		if(config->op_q_isfile) {
+			alpm_pkg_free(pkg);
+			pkg = NULL;
+		}
+	}
+
+	if(!match) {
+		ret = 1;
+	}
+
+	return(ret);
+}
+
+/* vim: set ts=2 sw=2 noet: */
diff -Naur pacman-3.5.2//src/pacman/remove.c pacman-color-3.5.2//src/pacman/remove.c
--- pacman-3.5.2//src/pacman/remove.c	2011-02-28 18:13:17.000000000 +0100
+++ pacman-color-3.5.2//src/pacman/remove.c	2011-04-19 17:21:28.000000000 +0200
@@ -106,7 +106,7 @@
 			case PM_ERR_PKG_INVALID_ARCH:
 				for(i = data; i; i = alpm_list_next(i)) {
 					char *pkg = alpm_list_getdata(i);
-					printf(_(":: package %s does not have a valid architecture\n"), pkg);
+					color_printf(COLOR_DOUBLECOLON, _(":: package %s does not have a valid architecture\n"), pkg);
 				}
 				break;
 			case PM_ERR_UNSATISFIED_DEPS:
@@ -114,7 +114,7 @@
 					pmdepmissing_t *miss = alpm_list_getdata(i);
 					pmdepend_t *dep = alpm_miss_get_dep(miss);
 					char *depstring = alpm_dep_compute_string(dep);
-					printf(_(":: %s: requires %s\n"), alpm_miss_get_target(miss),
+					color_printf(COLOR_DOUBLECOLON, _(":: %s: requires %s\n"), alpm_miss_get_target(miss),
 							depstring);
 					free(depstring);
 				}
@@ -137,7 +137,7 @@
 			holdpkg = 1;
 		}
 	}
-	if(holdpkg && (noyes(_("HoldPkg was found in target list. Do you want to continue?")) == 0)) {
+	if(holdpkg && (noyes(NULL, _("HoldPkg was found in target list. Do you want to continue?")) == 0)) {
 		retval = 1;
 		goto cleanup;
 	}
@@ -157,7 +157,7 @@
 	/* print targets and ask user confirmation */
 	display_targets(pkglist, 0);
 	printf("\n");
-	if(yesno(_("Do you want to remove these packages?")) == 0) {
+	if(yesno(NULL, _("Do you want to remove these packages?")) == 0) {
 		retval = 1;
 		goto cleanup;
 	}
diff -Naur pacman-3.5.2//src/pacman/sync.c pacman-color-3.5.2//src/pacman/sync.c
--- pacman-3.5.2//src/pacman/sync.c	2011-03-29 18:01:43.000000000 +0200
+++ pacman-color-3.5.2//src/pacman/sync.c	2011-04-19 17:21:28.000000000 +0200
@@ -102,7 +102,7 @@
 		/* We have a database that doesn't match any syncdb.
 		 * Ask the user if he wants to remove it. */
 		if(!found) {
-			if(!yesno(_("Do you want to remove %s?"), path)) {
+			if(!yesno(NULL, _("Do you want to remove %s?"), path)) {
 				continue;
 			}
 
@@ -124,8 +124,8 @@
 	int ret = 0;
 
 	dbpath = alpm_option_get_dbpath();
-	printf(_("Database directory: %s\n"), dbpath);
-	if(!yesno(_("Do you want to remove unused repositories?"))) {
+	color_printf(COLOR_WHITE_COLON, _("Database directory: %s\n"), dbpath);
+	if(!yesno(NULL, _("Do you want to remove unused repositories?"))) {
 		return(0);
 	}
 	/* The sync dbs were previously put in dbpath/ but are now in dbpath/sync/.
@@ -148,7 +148,7 @@
 	int ret = 0;
 
 	for(i = alpm_option_get_cachedirs(); i; i = alpm_list_next(i)) {
-		printf(_("Cache directory: %s\n"), (char*)alpm_list_getdata(i));
+		color_printf(COLOR_WHITE_COLON, _("Cache directory: %s\n"), (char*)alpm_list_getdata(i));
 	}
 
 	if(!config->cleanmethod) {
@@ -157,19 +157,19 @@
 	}
 
 	if(level == 1) {
-		printf(_("Packages to keep:\n"));
+		color_printf(COLOR_WHITE_COLON, _("Packages to keep:\n"));
 		if(config->cleanmethod & PM_CLEAN_KEEPINST) {
 			printf(_("  All locally installed packages\n"));
 		}
 		if(config->cleanmethod & PM_CLEAN_KEEPCUR) {
 			printf(_("  All current sync database packages\n"));
 		}
-		if(!yesno(_("Do you want to remove all other packages from cache?"))) {
+		if(!yesno(NULL, _("Do you want to remove all other packages from cache?"))) {
 			return(0);
 		}
 		printf(_("removing old packages from cache...\n"));
 	} else {
-		if(!noyes(_("Do you want to remove ALL files from cache?"))) {
+		if(!noyes(NULL, _("Do you want to remove ALL files from cache?"))) {
 			return(0);
 		}
 		printf(_("removing all files from cache...\n"));
@@ -212,7 +212,7 @@
 			 * files here that aren't valid packages. we also don't need a full
 			 * load of the package, just the metadata. */
 			if(alpm_pkg_load(path, 0, &localpkg) != 0 || localpkg == NULL) {
-				if(yesno(_("File %s does not seem to be a valid package, remove it?"), path)) {
+				if(yesno(NULL, _("File %s does not seem to be a valid package, remove it?"), path)) {
 					if(localpkg) {
 						alpm_pkg_free(localpkg);
 					}
@@ -306,9 +306,9 @@
 	if(lpkg) {
 		const char *lpkgver = alpm_pkg_get_version(lpkg);
 		if(strcmp(lpkgver,pkgver) == 0) {
-			printf(" [%s]", _("installed"));
+			color_printf(COLOR_CYAN_ALL, " [%s]", _("installed"));
 		} else {
-			printf(" [%s: %s]", _("installed"), lpkgver);
+			color_printf(COLOR_CYAN_ALL, " [%s: %s]", _("installed"), lpkgver);
 		}
 	}
 }
@@ -341,8 +341,9 @@
 			pmpkg_t *pkg = alpm_list_getdata(j);
 
 			if (!config->quiet) {
-				printf("%s/%s %s", alpm_db_get_name(db), alpm_pkg_get_name(pkg),
-							 alpm_pkg_get_version(pkg));
+				color_printf(COLOR_MAGENTA_ALL, "%s/", alpm_db_get_name(db));
+				color_printf(COLOR_WHITE_ALL, "%s ", alpm_pkg_get_name(pkg));
+				color_printf(COLOR_GREEN_ALL, "%s", alpm_pkg_get_version(pkg));
 			} else {
 				printf("%s", alpm_pkg_get_name(pkg));
 			}
@@ -358,16 +359,11 @@
 			if (!config->quiet) {
 				if((grp = alpm_pkg_get_groups(pkg)) != NULL) {
 					alpm_list_t *k;
-					printf(" (");
+					color_printf(COLOR_BLUE_ALL, " (");
 					for(k = grp; k; k = alpm_list_next(k)) {
 						const char *group = alpm_list_getdata(k);
-						printf("%s", group);
-						if(alpm_list_next(k)) {
-							/* only print a spacer if there are more groups */
-							printf(" ");
-						}
+						color_printf(COLOR_BLUE_ALL, "%s%s", group, (alpm_list_next(k) ? " " : ")"));
 					}
-					printf(")");
 				}
 
 				print_installed(db_local, pkg);
@@ -402,8 +398,8 @@
 					/* get names of packages in group */
 					for(k = alpm_grp_get_pkgs(grp); k; k = alpm_list_next(k)) {
 						if(!config->quiet) {
-							printf("%s %s\n", grpname,
-									alpm_pkg_get_name(alpm_list_getdata(k)));
+							color_printf(COLOR_BLUE_ALL, "%s ", grpname);
+							color_printf(COLOR_WHITE_ALL, "%s\n", alpm_pkg_get_name(alpm_list_getdata(k)));
 						} else {
 							printf("%s\n", alpm_pkg_get_name(alpm_list_getdata(k)));
 						}
@@ -421,8 +417,8 @@
 
 				if(level > 1) {
 					for(k = alpm_grp_get_pkgs(grp); k; k = alpm_list_next(k)) {
-						printf("%s %s\n", grpname,
-								alpm_pkg_get_name(alpm_list_getdata(k)));
+						color_printf(COLOR_BLUE_ALL, "%s ", grpname);
+						color_printf(COLOR_WHITE_ALL, "%s\n", alpm_pkg_get_name(alpm_list_getdata(k)));
 					}
 				} else {
 					/* print grp names only, no package names */
@@ -559,8 +555,9 @@
 			pmpkg_t *pkg = alpm_list_getdata(j);
 
 			if (!config->quiet) {
-				printf("%s %s %s", alpm_db_get_name(db), alpm_pkg_get_name(pkg),
-						alpm_pkg_get_version(pkg));
+				color_printf(COLOR_MAGENTA_ALL, "%s ", alpm_db_get_name(db));
+				color_printf(COLOR_WHITE_ALL, "%s ", alpm_pkg_get_name(pkg));
+				color_printf(COLOR_GREEN_ALL, "%s\n", alpm_pkg_get_version(pkg));
 				print_installed(db_local, pkg);
 				printf("\n");
 			} else {
@@ -640,7 +637,7 @@
 
 
 	if(config->print == 0) {
-		printf(_(":: There are %d members in group %s:\n"), count,
+		color_printf(COLOR_DOUBLECOLON, _(":: There are %d members in group %s:\n"), count,
 				group);
 		select_display(pkgs);
 		char *array = malloc(count);
@@ -747,7 +744,7 @@
 	}
 
 	if(config->op_s_upgrade) {
-		printf(_(":: Starting full system upgrade...\n"));
+		color_printf(COLOR_DOUBLECOLON, _(":: Starting full system upgrade...\n"));
 		alpm_logaction("starting full system upgrade\n");
 		if(alpm_sync_sysupgrade(config->op_s_upgrade >= 2) == -1) {
 			pm_fprintf(stderr, PM_LOG_ERROR, "%s\n", alpm_strerrorlast());
@@ -765,7 +762,7 @@
 			case PM_ERR_PKG_INVALID_ARCH:
 				for(i = data; i; i = alpm_list_next(i)) {
 					char *pkg = alpm_list_getdata(i);
-					printf(_(":: package %s does not have a valid architecture\n"), pkg);
+					color_printf(COLOR_DOUBLECOLON, _(":: package %s does not have a valid architecture\n"), pkg);
 				}
 				break;
 			case PM_ERR_UNSATISFIED_DEPS:
@@ -773,7 +770,7 @@
 					pmdepmissing_t *miss = alpm_list_getdata(i);
 					pmdepend_t *dep = alpm_miss_get_dep(miss);
 					char *depstring = alpm_dep_compute_string(dep);
-					printf(_(":: %s: requires %s\n"), alpm_miss_get_target(miss),
+					color_printf(COLOR_DOUBLECOLON, _(":: %s: requires %s\n"), alpm_miss_get_target(miss),
 							depstring);
 					free(depstring);
 				}
@@ -786,9 +783,9 @@
 					const char *reason = alpm_conflict_get_reason(conflict);
 					/* only print reason if it contains new information */
 					if(strcmp(package1, reason) == 0 || strcmp(package2, reason) == 0) {
-						printf(_(":: %s and %s are in conflict\n"), package1, package2);
+						color_printf(COLOR_DOUBLECOLON, _(":: %s and %s are in conflict\n"), package1, package2);
 					} else {
-						printf(_(":: %s and %s are in conflict (%s)\n"), package1, package2, reason);
+						color_printf(COLOR_DOUBLECOLON, _(":: %s and %s are in conflict (%s)\n"), package1, package2, reason);
 					}
 				}
 				break;
@@ -818,9 +815,9 @@
 
 	int confirm;
 	if(config->op_s_downloadonly) {
-		confirm = yesno(_("Proceed with download?"));
+		confirm = yesno(NULL, _("Proceed with download?"));
 	} else {
-		confirm = yesno(_("Proceed with installation?"));
+		confirm = yesno(NULL, _("Proceed with installation?"));
 	}
 	if(!confirm) {
 		goto cleanup;
@@ -842,7 +839,7 @@
 									alpm_fileconflict_get_ctarget(conflict));
 							break;
 						case PM_FILECONFLICT_FILESYSTEM:
-							printf(_("%s: %s exists in filesystem\n"),
+							color_printf(COLOR_WHITE_COLON, _("%s: %s exists in filesystem\n"),
 									alpm_fileconflict_get_target(conflict),
 									alpm_fileconflict_get_file(conflict));
 							break;
@@ -860,7 +857,7 @@
 				break;
 		}
 		/* TODO: stderr? */
-		printf(_("Errors occurred, no packages were upgraded.\n"));
+		color_printf(COLOR_RED_ALL, _("Errors occurred, no packages were upgraded.\n"));
 		retval = 1;
 		goto cleanup;
 	}
@@ -909,7 +906,7 @@
 
 	if(config->op_s_sync) {
 		/* grab a fresh package list */
-		printf(_(":: Synchronizing package databases...\n"));
+		color_printf(COLOR_DOUBLECOLON, _(":: Synchronizing package databases...\n"));
 		alpm_logaction("synchronizing package lists\n");
 		if(!sync_synctree(config->op_s_sync, sync_dbs)) {
 			return(1);
@@ -958,9 +955,9 @@
 			alpm_list_t *tmp = NULL;
 			if(config->op_s_upgrade || (tmp = alpm_list_diff(targets, packages, (alpm_list_fn_cmp)strcmp))) {
 				alpm_list_free(tmp);
-				printf(_(":: The following packages should be upgraded first :\n"));
-				list_display("   ", packages);
-				if(yesno(_(":: Do you want to cancel the current operation\n"
+				color_printf(COLOR_DOUBLECOLON, _(":: The following packages should be upgraded first :\n"));
+				list_display(NULL, "   ", packages);
+				if(yesno(COLOR_DOUBLECOLON2, _(":: Do you want to cancel the current operation\n"
 								":: and upgrade these packages now?"))) {
 					FREELIST(targs);
 					targs = packages;
diff -Naur pacman-3.5.2//src/pacman/sync.c.orig pacman-color-3.5.2//src/pacman/sync.c.orig
--- pacman-3.5.2//src/pacman/sync.c.orig	1970-01-01 01:00:00.000000000 +0100
+++ pacman-color-3.5.2//src/pacman/sync.c.orig	2011-03-29 18:01:43.000000000 +0200
@@ -0,0 +1,986 @@
+/*
+ *  sync.c
+ *
+ *  Copyright (c) 2006-2011 Pacman Development Team <pacman-dev@archlinux.org>
+ *  Copyright (c) 2002-2006 by Judd Vinet <jvinet@zeroflux.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "config.h"
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <limits.h>
+#include <unistd.h>
+#include <dirent.h>
+#include <sys/stat.h>
+
+#include <alpm.h>
+#include <alpm_list.h>
+
+/* pacman */
+#include "pacman.h"
+#include "util.h"
+#include "package.h"
+#include "conf.h"
+
+/* if keep_used != 0, then the db files which match an used syncdb
+ * will be kept  */
+static int sync_cleandb(const char *dbpath, int keep_used) {
+	DIR *dir;
+	struct dirent *ent;
+	alpm_list_t *syncdbs;
+
+	dir = opendir(dbpath);
+	if(dir == NULL) {
+		pm_fprintf(stderr, PM_LOG_ERROR, _("could not access database directory\n"));
+		return(1);
+	}
+
+	syncdbs = alpm_option_get_syncdbs();
+
+	rewinddir(dir);
+	/* step through the directory one file at a time */
+	while((ent = readdir(dir)) != NULL) {
+		char path[PATH_MAX];
+		struct stat buf;
+		int found = 0;
+		const char *dname = ent->d_name;
+		size_t len;
+
+		if(strcmp(dname, ".") == 0 || strcmp(dname, "..") == 0) {
+			continue;
+		}
+		/* skip the local and sync directories */
+		if(strcmp(dname, "sync") == 0 || strcmp(dname, "local") == 0) {
+			continue;
+		}
+		/* skip the db.lck file */
+		if(strcmp(dname, "db.lck") == 0) {
+			continue;
+		}
+
+		/* build the full path */
+		snprintf(path, PATH_MAX, "%s%s", dbpath, dname);
+
+		/* remove all non-skipped directories and non-database files */
+		stat(path, &buf);
+		len = strlen(path);
+		if(S_ISDIR(buf.st_mode) || strcmp(path + len - 3, ".db") != 0) {
+			if(rmrf(path)) {
+				pm_fprintf(stderr, PM_LOG_ERROR,
+					_("could not remove %s\n"), path);
+				closedir(dir);
+				return(1);
+			}
+			continue;
+		}
+
+		if(keep_used) {
+			alpm_list_t *i;
+			len = strlen(dname);
+			char *dbname = strndup(dname, len - 3);
+			for(i = syncdbs; i && !found; i = alpm_list_next(i)) {
+				pmdb_t *db = alpm_list_getdata(i);
+				found = !strcmp(dbname, alpm_db_get_name(db));
+			}
+			free(dbname);
+		}
+		/* We have a database that doesn't match any syncdb.
+		 * Ask the user if he wants to remove it. */
+		if(!found) {
+			if(!yesno(_("Do you want to remove %s?"), path)) {
+				continue;
+			}
+
+			if(rmrf(path)) {
+				pm_fprintf(stderr, PM_LOG_ERROR,
+					_("could not remove %s\n"), path);
+				closedir(dir);
+				return(1);
+			}
+		}
+	}
+	closedir(dir);
+	return(0);
+}
+
+static int sync_cleandb_all(void) {
+	const char *dbpath;
+	char newdbpath[PATH_MAX];
+	int ret = 0;
+
+	dbpath = alpm_option_get_dbpath();
+	printf(_("Database directory: %s\n"), dbpath);
+	if(!yesno(_("Do you want to remove unused repositories?"))) {
+		return(0);
+	}
+	/* The sync dbs were previously put in dbpath/ but are now in dbpath/sync/.
+	 * We will clean everything in dbpath/ except local/, sync/ and db.lck, and
+	 * only the unused sync dbs in dbpath/sync/ */
+	ret += sync_cleandb(dbpath, 0);
+
+	sprintf(newdbpath, "%s%s", dbpath, "sync/");
+	ret += sync_cleandb(newdbpath, 1);
+
+	printf(_("Database directory cleaned up\n"));
+	return(ret);
+}
+
+static int sync_cleancache(int level)
+{
+	alpm_list_t *i;
+	alpm_list_t *sync_dbs = alpm_option_get_syncdbs();
+	pmdb_t *db_local = alpm_option_get_localdb();
+	int ret = 0;
+
+	for(i = alpm_option_get_cachedirs(); i; i = alpm_list_next(i)) {
+		printf(_("Cache directory: %s\n"), (char*)alpm_list_getdata(i));
+	}
+
+	if(!config->cleanmethod) {
+		/* default to KeepInstalled if user did not specify */
+		config->cleanmethod = PM_CLEAN_KEEPINST;
+	}
+
+	if(level == 1) {
+		printf(_("Packages to keep:\n"));
+		if(config->cleanmethod & PM_CLEAN_KEEPINST) {
+			printf(_("  All locally installed packages\n"));
+		}
+		if(config->cleanmethod & PM_CLEAN_KEEPCUR) {
+			printf(_("  All current sync database packages\n"));
+		}
+		if(!yesno(_("Do you want to remove all other packages from cache?"))) {
+			return(0);
+		}
+		printf(_("removing old packages from cache...\n"));
+	} else {
+		if(!noyes(_("Do you want to remove ALL files from cache?"))) {
+			return(0);
+		}
+		printf(_("removing all files from cache...\n"));
+	}
+
+	for(i = alpm_option_get_cachedirs(); i; i = alpm_list_next(i)) {
+		const char *cachedir = alpm_list_getdata(i);
+		DIR *dir = opendir(cachedir);
+		struct dirent *ent;
+
+		if(dir == NULL) {
+			pm_fprintf(stderr, PM_LOG_ERROR,
+					_("could not access cache directory %s\n"), cachedir);
+			ret++;
+			continue;
+		}
+
+		rewinddir(dir);
+		/* step through the directory one file at a time */
+		while((ent = readdir(dir)) != NULL) {
+			char path[PATH_MAX];
+			int delete = 1;
+			pmpkg_t *localpkg = NULL, *pkg = NULL;
+			const char *local_name, *local_version;
+			alpm_list_t *j;
+
+			if(strcmp(ent->d_name, ".") == 0 || strcmp(ent->d_name, "..") == 0) {
+				continue;
+			}
+			/* build the full filepath */
+			snprintf(path, PATH_MAX, "%s%s", cachedir, ent->d_name);
+
+			/* short circuit for removing all packages from cache */
+			if(level > 1) {
+				unlink(path);
+				continue;
+			}
+
+			/* attempt to load the package, prompt removal on failures as we may have
+			 * files here that aren't valid packages. we also don't need a full
+			 * load of the package, just the metadata. */
+			if(alpm_pkg_load(path, 0, &localpkg) != 0 || localpkg == NULL) {
+				if(yesno(_("File %s does not seem to be a valid package, remove it?"), path)) {
+					if(localpkg) {
+						alpm_pkg_free(localpkg);
+					}
+					unlink(path);
+				}
+				continue;
+			}
+			local_name = alpm_pkg_get_name(localpkg);
+			local_version = alpm_pkg_get_version(localpkg);
+
+			if(config->cleanmethod & PM_CLEAN_KEEPINST) {
+				/* check if this package is in the local DB */
+				pkg = alpm_db_get_pkg(db_local, local_name);
+				if(pkg != NULL && alpm_pkg_vercmp(local_version,
+							alpm_pkg_get_version(pkg)) == 0) {
+					/* package was found in local DB and version matches, keep it */
+					pm_printf(PM_LOG_DEBUG, "pkg %s-%s found in local db\n",
+							local_name, local_version);
+					delete = 0;
+				}
+			}
+			if(config->cleanmethod & PM_CLEAN_KEEPCUR) {
+				/* check if this package is in a sync DB */
+				for(j = sync_dbs; j && delete; j = alpm_list_next(j)) {
+					pmdb_t *db = alpm_list_getdata(j);
+					pkg = alpm_db_get_pkg(db, local_name);
+					if(pkg != NULL && alpm_pkg_vercmp(local_version,
+								alpm_pkg_get_version(pkg)) == 0) {
+						/* package was found in a sync DB and version matches, keep it */
+						pm_printf(PM_LOG_DEBUG, "pkg %s-%s found in sync db\n",
+								local_name, local_version);
+						delete = 0;
+					}
+				}
+			}
+			/* free the local file package */
+			alpm_pkg_free(localpkg);
+
+			if(delete) {
+				unlink(path);
+			}
+		}
+		closedir(dir);
+	}
+
+	return(ret);
+}
+
+static int sync_synctree(int level, alpm_list_t *syncs)
+{
+	alpm_list_t *i;
+	int success = 0, ret;
+
+	if(trans_init(0) == -1) {
+		return(0);
+	}
+
+	for(i = syncs; i; i = alpm_list_next(i)) {
+		pmdb_t *db = alpm_list_getdata(i);
+
+		ret = alpm_db_update((level < 2 ? 0 : 1), db);
+		if(ret < 0) {
+			pm_fprintf(stderr, PM_LOG_ERROR, _("failed to update %s (%s)\n"),
+					alpm_db_get_name(db), alpm_strerrorlast());
+		} else if(ret == 1) {
+			printf(_(" %s is up to date\n"), alpm_db_get_name(db));
+			success++;
+		} else {
+			success++;
+		}
+	}
+
+	if(trans_release() == -1) {
+		return(0);
+	}
+	/* We should always succeed if at least one DB was upgraded - we may possibly
+	 * fail later with unresolved deps, but that should be rare, and would be
+	 * expected
+	 */
+	if(!success) {
+		pm_fprintf(stderr, PM_LOG_ERROR, _("failed to synchronize any databases\n"));
+	}
+	return(success > 0);
+}
+
+static void print_installed(pmdb_t *db_local, pmpkg_t *pkg)
+{
+	const char *pkgname = alpm_pkg_get_name(pkg);
+	const char *pkgver = alpm_pkg_get_version(pkg);
+	pmpkg_t *lpkg = alpm_db_get_pkg(db_local, pkgname);
+	if(lpkg) {
+		const char *lpkgver = alpm_pkg_get_version(lpkg);
+		if(strcmp(lpkgver,pkgver) == 0) {
+			printf(" [%s]", _("installed"));
+		} else {
+			printf(" [%s: %s]", _("installed"), lpkgver);
+		}
+	}
+}
+
+/* search the sync dbs for a matching package */
+static int sync_search(alpm_list_t *syncs, alpm_list_t *targets)
+{
+	alpm_list_t *i, *j, *ret;
+	int freelist;
+	int found = 0;
+	pmdb_t *db_local = alpm_option_get_localdb();
+
+	for(i = syncs; i; i = alpm_list_next(i)) {
+		pmdb_t *db = alpm_list_getdata(i);
+		/* if we have a targets list, search for packages matching it */
+		if(targets) {
+			ret = alpm_db_search(db, targets);
+			freelist = 1;
+		} else {
+			ret = alpm_db_get_pkgcache(db);
+			freelist = 0;
+		}
+		if(ret == NULL) {
+			continue;
+		} else {
+			found = 1;
+		}
+		for(j = ret; j; j = alpm_list_next(j)) {
+			alpm_list_t *grp;
+			pmpkg_t *pkg = alpm_list_getdata(j);
+
+			if (!config->quiet) {
+				printf("%s/%s %s", alpm_db_get_name(db), alpm_pkg_get_name(pkg),
+							 alpm_pkg_get_version(pkg));
+			} else {
+				printf("%s", alpm_pkg_get_name(pkg));
+			}
+
+			/* print the package size with the output if ShowSize option set */
+			if(!config->quiet && config->showsize) {
+				/* Convert byte size to MB */
+				double mbsize = (double)alpm_pkg_get_size(pkg) / (1024.0 * 1024.0);
+
+				printf(" [%.2f MB]", mbsize);
+			}
+
+			if (!config->quiet) {
+				if((grp = alpm_pkg_get_groups(pkg)) != NULL) {
+					alpm_list_t *k;
+					printf(" (");
+					for(k = grp; k; k = alpm_list_next(k)) {
+						const char *group = alpm_list_getdata(k);
+						printf("%s", group);
+						if(alpm_list_next(k)) {
+							/* only print a spacer if there are more groups */
+							printf(" ");
+						}
+					}
+					printf(")");
+				}
+
+				print_installed(db_local, pkg);
+
+				/* we need a newline and initial indent first */
+				printf("\n    ");
+				indentprint(alpm_pkg_get_desc(pkg), 4);
+			}
+			printf("\n");
+		}
+		/* we only want to free if the list was a search list */
+		if(freelist) {
+			alpm_list_free(ret);
+		}
+	}
+
+	return(!found);
+}
+
+static int sync_group(int level, alpm_list_t *syncs, alpm_list_t *targets)
+{
+	alpm_list_t *i, *j, *k;
+
+	if(targets) {
+		for(i = targets; i; i = alpm_list_next(i)) {
+			const char *grpname = alpm_list_getdata(i);
+			for(j = syncs; j; j = alpm_list_next(j)) {
+				pmdb_t *db = alpm_list_getdata(j);
+				pmgrp_t *grp = alpm_db_readgrp(db, grpname);
+
+				if(grp) {
+					/* get names of packages in group */
+					for(k = alpm_grp_get_pkgs(grp); k; k = alpm_list_next(k)) {
+						if(!config->quiet) {
+							printf("%s %s\n", grpname,
+									alpm_pkg_get_name(alpm_list_getdata(k)));
+						} else {
+							printf("%s\n", alpm_pkg_get_name(alpm_list_getdata(k)));
+						}
+					}
+				}
+			}
+		}
+	} else {
+		for(i = syncs; i; i = alpm_list_next(i)) {
+			pmdb_t *db = alpm_list_getdata(i);
+
+			for(j = alpm_db_get_grpcache(db); j; j = alpm_list_next(j)) {
+				pmgrp_t *grp = alpm_list_getdata(j);
+				const char *grpname = alpm_grp_get_name(grp);
+
+				if(level > 1) {
+					for(k = alpm_grp_get_pkgs(grp); k; k = alpm_list_next(k)) {
+						printf("%s %s\n", grpname,
+								alpm_pkg_get_name(alpm_list_getdata(k)));
+					}
+				} else {
+					/* print grp names only, no package names */
+					printf("%s\n", grpname);
+				}
+			}
+		}
+	}
+
+	return(0);
+}
+
+static int sync_info(alpm_list_t *syncs, alpm_list_t *targets)
+{
+	alpm_list_t *i, *j, *k;
+	int ret = 0;
+
+	if(targets) {
+		for(i = targets; i; i = alpm_list_next(i)) {
+			pmdb_t *db = NULL;
+			int foundpkg = 0;
+
+			char target[512]; /* TODO is this enough space? */
+			char *repo = NULL, *pkgstr = NULL;
+
+			strncpy(target, i->data, 512);
+			pkgstr = strchr(target, '/');
+			if(pkgstr) {
+				repo = target;
+				*pkgstr = '\0';
+				++pkgstr;
+
+				for(j = syncs; j; j = alpm_list_next(j)) {
+					db = alpm_list_getdata(j);
+					if(strcmp(repo, alpm_db_get_name(db)) == 0) {
+						break;
+					}
+					db = NULL;
+				}
+
+				if(!db) {
+					pm_fprintf(stderr, PM_LOG_ERROR,
+						_("repository '%s' does not exist\n"), repo);
+					return(1);
+				}
+
+				for(k = alpm_db_get_pkgcache(db); k; k = alpm_list_next(k)) {
+					pmpkg_t *pkg = alpm_list_getdata(k);
+
+					if(strcmp(alpm_pkg_get_name(pkg), pkgstr) == 0) {
+						dump_pkg_sync(pkg, alpm_db_get_name(db), config->op_s_info);
+						foundpkg = 1;
+						break;
+					}
+				}
+
+				if(!foundpkg) {
+					pm_fprintf(stderr, PM_LOG_ERROR,
+						_("package '%s' was not found in repository '%s'\n"), pkgstr, repo);
+					ret++;
+				}
+			} else {
+				pkgstr = target;
+
+				for(j = syncs; j; j = alpm_list_next(j)) {
+					pmdb_t *db = alpm_list_getdata(j);
+
+					for(k = alpm_db_get_pkgcache(db); k; k = alpm_list_next(k)) {
+						pmpkg_t *pkg = alpm_list_getdata(k);
+
+						if(strcmp(alpm_pkg_get_name(pkg), pkgstr) == 0) {
+							dump_pkg_sync(pkg, alpm_db_get_name(db), config->op_s_info);
+							foundpkg = 1;
+							break;
+						}
+					}
+				}
+				if(!foundpkg) {
+					pm_fprintf(stderr, PM_LOG_ERROR,
+						_("package '%s' was not found\n"), pkgstr);
+					ret++;
+				}
+			}
+		}
+	} else {
+		for(i = syncs; i; i = alpm_list_next(i)) {
+			pmdb_t *db = alpm_list_getdata(i);
+
+			for(j = alpm_db_get_pkgcache(db); j; j = alpm_list_next(j)) {
+				dump_pkg_sync(alpm_list_getdata(j), alpm_db_get_name(db), config->op_s_info);
+			}
+		}
+	}
+
+	return(ret);
+}
+
+static int sync_list(alpm_list_t *syncs, alpm_list_t *targets)
+{
+	alpm_list_t *i, *j, *ls = NULL;
+	pmdb_t *db_local = alpm_option_get_localdb();
+
+	if(targets) {
+		for(i = targets; i; i = alpm_list_next(i)) {
+			const char *repo = alpm_list_getdata(i);
+			pmdb_t *db = NULL;
+
+			for(j = syncs; j; j = alpm_list_next(j)) {
+				pmdb_t *d = alpm_list_getdata(j);
+
+				if(strcmp(repo, alpm_db_get_name(d)) == 0) {
+					db = d;
+					break;
+				}
+			}
+
+			if(db == NULL) {
+				pm_fprintf(stderr, PM_LOG_ERROR,
+					_("repository \"%s\" was not found.\n"),repo);
+				alpm_list_free(ls);
+				return(1);
+			}
+
+			ls = alpm_list_add(ls, db);
+		}
+	} else {
+		ls = syncs;
+	}
+
+	for(i = ls; i; i = alpm_list_next(i)) {
+		pmdb_t *db = alpm_list_getdata(i);
+
+		for(j = alpm_db_get_pkgcache(db); j; j = alpm_list_next(j)) {
+			pmpkg_t *pkg = alpm_list_getdata(j);
+
+			if (!config->quiet) {
+				printf("%s %s %s", alpm_db_get_name(db), alpm_pkg_get_name(pkg),
+						alpm_pkg_get_version(pkg));
+				print_installed(db_local, pkg);
+				printf("\n");
+			} else {
+				printf("%s\n", alpm_pkg_get_name(pkg));
+			}
+		}
+	}
+
+	if(targets) {
+		alpm_list_free(ls);
+	}
+
+	return(0);
+}
+
+static alpm_list_t *syncfirst(void) {
+	alpm_list_t *i, *res = NULL;
+	pmdb_t *db_local = alpm_option_get_localdb();
+
+	for(i = config->syncfirst; i; i = alpm_list_next(i)) {
+		char *pkgname = alpm_list_getdata(i);
+		pmpkg_t *pkg = alpm_db_get_pkg(db_local, pkgname);
+		if(pkg == NULL) {
+			continue;
+		}
+
+		if(alpm_sync_newversion(pkg, alpm_option_get_syncdbs())) {
+			res = alpm_list_add(res, strdup(pkgname));
+		}
+	}
+
+	return(res);
+}
+
+static pmdb_t *get_db(const char *dbname)
+{
+	alpm_list_t *i;
+	for(i = alpm_option_get_syncdbs(); i; i = i->next) {
+		pmdb_t *db = i->data;
+		if(strcmp(alpm_db_get_name(db), dbname) == 0) {
+			return(db);
+		}
+	}
+	return(NULL);
+}
+
+static int process_pkg(pmpkg_t *pkg)
+{
+	int ret = alpm_add_pkg(pkg);
+
+	if(ret == -1) {
+		if(pm_errno == PM_ERR_TRANS_DUP_TARGET
+				|| pm_errno == PM_ERR_PKG_IGNORED) {
+			/* just skip duplicate or ignored targets */
+			pm_printf(PM_LOG_WARNING, _("skipping target: %s\n"), alpm_pkg_get_name(pkg));
+			return(0);
+		} else {
+			pm_fprintf(stderr, PM_LOG_ERROR, "'%s': %s\n", alpm_pkg_get_name(pkg),
+					alpm_strerrorlast());
+			return(1);
+		}
+	}
+	return(0);
+}
+
+static int process_group(alpm_list_t *dbs, char *group)
+{
+	int ret = 0;
+	alpm_list_t *i;
+	alpm_list_t *pkgs = alpm_find_grp_pkgs(dbs, group);
+	int count = alpm_list_count(pkgs);
+
+	if(!count) {
+		pm_fprintf(stderr, PM_LOG_ERROR, _("target not found: %s\n"), group);
+		return(1);
+	}
+
+
+	if(config->print == 0) {
+		printf(_(":: There are %d members in group %s:\n"), count,
+				group);
+		select_display(pkgs);
+		char *array = malloc(count);
+		multiselect_question(array, count);
+		int n = 0;
+		for(i = pkgs; i; i = alpm_list_next(i)) {
+			if(array[n++] == 0)
+				continue;
+			pmpkg_t *pkg = alpm_list_getdata(i);
+
+			if(process_pkg(pkg) == 1) {
+				ret = 1;
+				free(array);
+				goto cleanup;
+			}
+		}
+	} else {
+		for(i = pkgs; i; i = alpm_list_next(i)) {
+			pmpkg_t *pkg = alpm_list_getdata(i);
+
+			if(process_pkg(pkg) == 1) {
+				ret = 1;
+				goto cleanup;
+			}
+		}
+	}
+cleanup:
+	alpm_list_free(pkgs);
+	return(ret);
+}
+
+static int process_targname(alpm_list_t *dblist, char *targname)
+{
+	pmpkg_t *pkg = alpm_find_dbs_satisfier(dblist, targname);
+
+	/* #FS23342 - skip ignored packages when user says no */
+	if(pm_errno == PM_ERR_PKG_IGNORED) {
+			pm_printf(PM_LOG_WARNING, _("skipping target: %s\n"), targname);
+			pm_errno = 0;
+			return(0);
+	}
+
+	if(pkg) {
+		return(process_pkg(pkg));
+	}
+	/* fallback on group */
+	return(process_group(dblist, targname));
+}
+
+static int process_target(char *target)
+{
+	/* process targets */
+	char *targstring = strdup(target);
+	char *targname = strchr(targstring, '/');
+	char *dbname = NULL;
+	int ret = 0;
+	alpm_list_t *dblist = NULL;
+
+	if(targname) {
+		pmdb_t *db = NULL;
+
+		*targname = '\0';
+		targname++;
+		dbname = targstring;
+		db = get_db(dbname);
+		if(!db) {
+			pm_fprintf(stderr, PM_LOG_ERROR, _("database not found: %s\n"),
+					dbname);
+			ret = 1;
+			goto cleanup;
+		}
+		dblist = alpm_list_add(dblist, db);
+		ret = process_targname(dblist, targname);
+		alpm_list_free(dblist);
+	} else {
+		targname = targstring;
+		dblist = alpm_option_get_syncdbs();
+		ret = process_targname(dblist, targname);
+	}
+cleanup:
+	free(targstring);
+	return(ret);
+}
+
+static int sync_trans(alpm_list_t *targets)
+{
+	int retval = 0;
+	alpm_list_t *data = NULL;
+	alpm_list_t *packages = NULL;
+	alpm_list_t *i;
+
+	/* Step 1: create a new transaction... */
+	if(trans_init(config->flags) == -1) {
+		return(1);
+	}
+
+	/* process targets */
+	for(i = targets; i; i = alpm_list_next(i)) {
+		char *targ = alpm_list_getdata(i);
+		if(process_target(targ) == 1) {
+			retval = 1;
+			goto cleanup;
+		}
+	}
+
+	if(config->op_s_upgrade) {
+		printf(_(":: Starting full system upgrade...\n"));
+		alpm_logaction("starting full system upgrade\n");
+		if(alpm_sync_sysupgrade(config->op_s_upgrade >= 2) == -1) {
+			pm_fprintf(stderr, PM_LOG_ERROR, "%s\n", alpm_strerrorlast());
+			retval = 1;
+			goto cleanup;
+		}
+	}
+
+	/* Step 2: "compute" the transaction based on targets and flags */
+	if(alpm_trans_prepare(&data) == -1) {
+		pm_fprintf(stderr, PM_LOG_ERROR, _("failed to prepare transaction (%s)\n"),
+		        alpm_strerrorlast());
+		switch(pm_errno) {
+			alpm_list_t *i;
+			case PM_ERR_PKG_INVALID_ARCH:
+				for(i = data; i; i = alpm_list_next(i)) {
+					char *pkg = alpm_list_getdata(i);
+					printf(_(":: package %s does not have a valid architecture\n"), pkg);
+				}
+				break;
+			case PM_ERR_UNSATISFIED_DEPS:
+				for(i = data; i; i = alpm_list_next(i)) {
+					pmdepmissing_t *miss = alpm_list_getdata(i);
+					pmdepend_t *dep = alpm_miss_get_dep(miss);
+					char *depstring = alpm_dep_compute_string(dep);
+					printf(_(":: %s: requires %s\n"), alpm_miss_get_target(miss),
+							depstring);
+					free(depstring);
+				}
+				break;
+			case PM_ERR_CONFLICTING_DEPS:
+				for(i = data; i; i = alpm_list_next(i)) {
+					pmconflict_t *conflict = alpm_list_getdata(i);
+					const char *package1 = alpm_conflict_get_package1(conflict);
+					const char *package2 = alpm_conflict_get_package2(conflict);
+					const char *reason = alpm_conflict_get_reason(conflict);
+					/* only print reason if it contains new information */
+					if(strcmp(package1, reason) == 0 || strcmp(package2, reason) == 0) {
+						printf(_(":: %s and %s are in conflict\n"), package1, package2);
+					} else {
+						printf(_(":: %s and %s are in conflict (%s)\n"), package1, package2, reason);
+					}
+				}
+				break;
+			default:
+				break;
+		}
+		retval = 1;
+		goto cleanup;
+	}
+
+	packages = alpm_trans_get_add();
+	if(packages == NULL) {
+		/* nothing to do: just exit without complaining */
+		printf(_(" there is nothing to do\n"));
+		goto cleanup;
+	}
+
+	/* Step 3: actually perform the operation */
+	if(config->print) {
+		print_packages(packages);
+		goto cleanup;
+	}
+
+	display_targets(alpm_trans_get_remove(), 0);
+	display_targets(alpm_trans_get_add(), 1);
+	printf("\n");
+
+	int confirm;
+	if(config->op_s_downloadonly) {
+		confirm = yesno(_("Proceed with download?"));
+	} else {
+		confirm = yesno(_("Proceed with installation?"));
+	}
+	if(!confirm) {
+		goto cleanup;
+	}
+
+	if(alpm_trans_commit(&data) == -1) {
+		pm_fprintf(stderr, PM_LOG_ERROR, _("failed to commit transaction (%s)\n"),
+		        alpm_strerrorlast());
+		switch(pm_errno) {
+			alpm_list_t *i;
+			case PM_ERR_FILE_CONFLICTS:
+				for(i = data; i; i = alpm_list_next(i)) {
+					pmfileconflict_t *conflict = alpm_list_getdata(i);
+					switch(alpm_fileconflict_get_type(conflict)) {
+						case PM_FILECONFLICT_TARGET:
+							printf(_("%s exists in both '%s' and '%s'\n"),
+									alpm_fileconflict_get_file(conflict),
+									alpm_fileconflict_get_target(conflict),
+									alpm_fileconflict_get_ctarget(conflict));
+							break;
+						case PM_FILECONFLICT_FILESYSTEM:
+							printf(_("%s: %s exists in filesystem\n"),
+									alpm_fileconflict_get_target(conflict),
+									alpm_fileconflict_get_file(conflict));
+							break;
+					}
+				}
+				break;
+			case PM_ERR_PKG_INVALID:
+			case PM_ERR_DLT_INVALID:
+				for(i = data; i; i = alpm_list_next(i)) {
+					char *filename = alpm_list_getdata(i);
+					printf(_("%s is invalid or corrupted\n"), filename);
+				}
+				break;
+			default:
+				break;
+		}
+		/* TODO: stderr? */
+		printf(_("Errors occurred, no packages were upgraded.\n"));
+		retval = 1;
+		goto cleanup;
+	}
+
+	/* Step 4: release transaction resources */
+cleanup:
+	if(data) {
+		FREELIST(data);
+	}
+	if(trans_release() == -1) {
+		retval = 1;
+	}
+
+	return(retval);
+}
+
+int pacman_sync(alpm_list_t *targets)
+{
+	alpm_list_t *sync_dbs = NULL;
+
+	/* clean the cache */
+	if(config->op_s_clean) {
+		int ret = 0;
+
+		if(trans_init(0) == -1) {
+			return(1);
+		}
+
+		ret += sync_cleancache(config->op_s_clean);
+		printf("\n");
+		ret += sync_cleandb_all();
+
+		if(trans_release() == -1) {
+			ret++;
+		}
+
+		return(ret);
+	}
+
+	/* ensure we have at least one valid sync db set up */
+	sync_dbs = alpm_option_get_syncdbs();
+	if(sync_dbs == NULL || alpm_list_count(sync_dbs) == 0) {
+		pm_printf(PM_LOG_ERROR, _("no usable package repositories configured.\n"));
+		return(1);
+	}
+
+	if(config->op_s_sync) {
+		/* grab a fresh package list */
+		printf(_(":: Synchronizing package databases...\n"));
+		alpm_logaction("synchronizing package lists\n");
+		if(!sync_synctree(config->op_s_sync, sync_dbs)) {
+			return(1);
+		}
+	}
+
+	/* search for a package */
+	if(config->op_s_search) {
+		return(sync_search(sync_dbs, targets));
+	}
+
+	/* look for groups */
+	if(config->group) {
+		return(sync_group(config->group, sync_dbs, targets));
+	}
+
+	/* get package info */
+	if(config->op_s_info) {
+		return(sync_info(sync_dbs, targets));
+	}
+
+	/* get a listing of files in sync DBs */
+	if(config->op_q_list) {
+		return(sync_list(sync_dbs, targets));
+	}
+
+	if(targets == NULL) {
+		if(config->op_s_upgrade) {
+			/* proceed */
+		} else if(config->op_s_sync) {
+			return(0);
+		} else {
+			/* don't proceed here unless we have an operation that doesn't require a
+			 * target list */
+			pm_printf(PM_LOG_ERROR, _("no targets specified (use -h for help)\n"));
+			return(1);
+		}
+	}
+
+	alpm_list_t *targs = alpm_list_strdup(targets);
+	if(!(config->flags & PM_TRANS_FLAG_DOWNLOADONLY) && !config->print) {
+		/* check for newer versions of packages to be upgraded first */
+		alpm_list_t *packages = syncfirst();
+		if(packages) {
+			/* Do not ask user if all the -S targets are SyncFirst packages, see FS#15810 */
+			alpm_list_t *tmp = NULL;
+			if(config->op_s_upgrade || (tmp = alpm_list_diff(targets, packages, (alpm_list_fn_cmp)strcmp))) {
+				alpm_list_free(tmp);
+				printf(_(":: The following packages should be upgraded first :\n"));
+				list_display("   ", packages);
+				if(yesno(_(":: Do you want to cancel the current operation\n"
+								":: and upgrade these packages now?"))) {
+					FREELIST(targs);
+					targs = packages;
+					config->flags = 0;
+					config->op_s_upgrade = 0;
+				} else {
+					FREELIST(packages);
+				}
+				printf("\n");
+			} else {
+				pm_printf(PM_LOG_DEBUG, "skipping SyncFirst dialog\n");
+				FREELIST(packages);
+			}
+		}
+	}
+
+	int ret = sync_trans(targs);
+	FREELIST(targs);
+
+	return(ret);
+}
+
+/* vim: set ts=2 sw=2 noet: */
diff -Naur pacman-3.5.2//src/pacman/upgrade.c pacman-color-3.5.2//src/pacman/upgrade.c
--- pacman-3.5.2//src/pacman/upgrade.c	2011-02-28 18:13:17.000000000 +0100
+++ pacman-color-3.5.2//src/pacman/upgrade.c	2011-04-19 17:21:28.000000000 +0200
@@ -99,7 +99,7 @@
 			case PM_ERR_PKG_INVALID_ARCH:
 				for(i = data; i; i = alpm_list_next(i)) {
 					char *pkg = alpm_list_getdata(i);
-					printf(_(":: package %s does not have a valid architecture\n"), pkg);
+					color_printf(COLOR_DOUBLECOLON, _(":: package %s does not have a valid architecture\n"), pkg);
 				}
 				break;
 			case PM_ERR_UNSATISFIED_DEPS:
@@ -111,7 +111,7 @@
 					/* TODO indicate if the error was a virtual package or not:
 					 *		:: %s: requires %s, provided by %s
 					 */
-					printf(_(":: %s: requires %s\n"), alpm_miss_get_target(miss),
+					color_printf(COLOR_DOUBLECOLON, _(":: %s: requires %s\n"), alpm_miss_get_target(miss),
 							depstring);
 					free(depstring);
 				}
@@ -124,9 +124,9 @@
 					const char *reason = alpm_conflict_get_reason(conflict);
 					/* only print reason if it contains new information */
 					if(strcmp(package1, reason) == 0 || strcmp(package2, reason) == 0) {
-						printf(_(":: %s and %s are in conflict\n"), package1, package2);
+						color_printf(COLOR_DOUBLECOLON, _(":: %s and %s are in conflict\n"), package1, package2);
 					} else {
-						printf(_(":: %s and %s are in conflict (%s)\n"), package1, package2, reason);
+						color_printf(COLOR_DOUBLECOLON, _(":: %s and %s are in conflict (%s)\n"), package1, package2, reason);
 					}
 				}
 				break;
@@ -156,7 +156,7 @@
 	display_targets(alpm_trans_get_remove(), 0);
 	display_targets(alpm_trans_get_add(), 1);
 	printf("\n");
-	int confirm = yesno(_("Proceed with installation?"));
+	int confirm = yesno(NULL, _("Proceed with installation?"));
 	if(!confirm) {
 		trans_release();
 		return(retval);
@@ -178,7 +178,7 @@
 									alpm_fileconflict_get_ctarget(conflict));
 							break;
 						case PM_FILECONFLICT_FILESYSTEM:
-							printf(_("%s: %s exists in filesystem\n"),
+							color_printf(COLOR_WHITE_COLON, _("%s: %s exists in filesystem\n"),
 									alpm_fileconflict_get_target(conflict),
 									alpm_fileconflict_get_file(conflict));
 							break;
diff -Naur pacman-3.5.2//src/pacman/util.c pacman-color-3.5.2//src/pacman/util.c
--- pacman-3.5.2//src/pacman/util.c	2011-04-05 02:03:27.000000000 +0200
+++ pacman-color-3.5.2//src/pacman/util.c	2011-04-19 17:21:28.000000000 +0200
@@ -46,6 +46,20 @@
 #include "conf.h"
 #include "callback.h"
 
+#define COLOR_LEN 8
+
+typedef struct __colortab_t {
+	char red[COLOR_LEN + 1];
+	char green[COLOR_LEN + 1];
+	char yellow[COLOR_LEN + 1];
+	char blue[COLOR_LEN + 1];
+	char magenta[COLOR_LEN + 1];
+	char cyan[COLOR_LEN + 1];
+	char white[COLOR_LEN + 1];
+	char none[COLOR_LEN + 1];
+} colortab_t;
+
+static colortab_t colortab;
 
 int trans_init(pmtransflag_t flags)
 {
@@ -423,12 +437,12 @@
 	return(len);
 }
 
-void string_display(const char *title, const char *string)
+void string_display(const colordata_t *colors_title, const char *title, const char *string)
 {
 	int len = 0;
 
 	if(title) {
-		printf("%s ", title);
+		color_printf(colors_title, "%s ", title);
 	}
 	if(string == NULL || string[0] == '\0') {
 		printf(_("None"));
@@ -440,14 +454,14 @@
 	printf("\n");
 }
 
-void list_display(const char *title, const alpm_list_t *list)
+void list_display(const colordata_t *colors_title, const char *title, const alpm_list_t *list)
 {
 	const alpm_list_t *i;
 	int cols, len = 0;
 
 	if(title) {
 		len = string_length(title) + 1;
-		printf("%s ", title);
+		color_printf(colors_title, "%s ", title);
 	}
 
 	if(!list) {
@@ -476,14 +490,14 @@
 	}
 }
 
-void list_display_linebreak(const char *title, const alpm_list_t *list)
+void list_display_linebreak(const colordata_t *colors_title, const char *title, const alpm_list_t *list)
 {
 	const alpm_list_t *i;
 	int len = 0;
 
 	if(title) {
 		len = string_length(title) + 1;
-		printf("%s ", title);
+		color_printf(colors_title, "%s ", title);
 	}
 
 	if(!list) {
@@ -544,21 +558,21 @@
 
 	if(install) {
 		pm_asprintf(&str, _("Targets (%d):"), alpm_list_count(targets));
-		list_display(str, targets);
+		list_display(COLOR_YELLOW_ALL, str, targets);
 		free(str);
 		printf("\n");
 
-		printf(_("Total Download Size:    %.2f MB\n"), mbdlsize);
+		color_printf(COLOR_WHITE_COLON, _("Total Download Size:    %.2f MB\n"), mbdlsize);
 		if(!(config->flags & PM_TRANS_FLAG_DOWNLOADONLY)) {
-			printf(_("Total Installed Size:   %.2f MB\n"), mbisize);
+			color_printf(COLOR_WHITE_COLON, _("Total Installed Size:   %.2f MB\n"), mbisize);
 		}
 	} else {
 		pm_asprintf(&str, _("Remove (%d):"), alpm_list_count(targets));
-		list_display(str, targets);
+		list_display(COLOR_RED_ALL, str, targets);
 		free(str);
 		printf("\n");
 
-		printf(_("Total Removed Size:   %.2f MB\n"), mbisize);
+		color_printf(COLOR_WHITE_COLON, _("Total Removed Size:   %.2f MB\n"), mbisize);
 	}
 
 	FREELIST(targets);
@@ -667,7 +681,7 @@
 	alpm_list_t *optdeps = alpm_list_diff(new,old,str_cmp);
 	if(optdeps) {
 		printf(_("New optional dependencies for %s\n"), alpm_pkg_get_name(newpkg));
-		list_display_linebreak("   ", optdeps);
+		list_display_linebreak(NULL, "   ", optdeps);
 	}
 	alpm_list_free(optdeps);
 }
@@ -677,7 +691,7 @@
 	alpm_list_t *optdeps = alpm_pkg_get_optdepends(pkg);
 	if(optdeps) {
 		printf(_("Optional dependencies for %s\n"), alpm_pkg_get_name(pkg));
-		list_display_linebreak("   ", optdeps);
+		list_display_linebreak(NULL, "   ", optdeps);
 	}
 }
 
@@ -685,9 +699,9 @@
 {
 	const char *prefix= "  ";
 
-	printf(":: ");
-	printf(_("Repository %s\n"), dbname);
-	list_display(prefix, list);
+	color_printf(COLOR_BLUE_ALL, ":: ");
+	color_printf(COLOR_WHITE_ALL, _("Repository %s\n"), dbname);
+	list_display(NULL, prefix, list);
 }
 
 void select_display(const alpm_list_t *pkglist)
@@ -869,7 +883,7 @@
 
 
 /* presents a prompt and gets a Y/N answer */
-static int question(short preset, char *fmt, va_list args)
+static int question(const colordata_t *colors, short preset, char *fmt, va_list args)
 {
 	char response[32];
 	FILE *stream;
@@ -885,7 +899,7 @@
 	fflush(stdout);
 	fflush(stderr);
 
-	vfprintf(stream, fmt, args);
+	color_vfprintf(stream, colors, fmt, args);
 
 	if(preset) {
 		fprintf(stream, " %s ", _("[Y/n]"));
@@ -914,25 +928,25 @@
 	return(0);
 }
 
-int yesno(char *fmt, ...)
+int yesno(const colordata_t *colors, char *fmt, ...)
 {
 	int ret;
 	va_list args;
 
 	va_start(args, fmt);
-	ret = question(1, fmt, args);
+	ret = question(colors, 1, fmt, args);
 	va_end(args);
 
 	return(ret);
 }
 
-int noyes(char *fmt, ...)
+int noyes(const colordata_t *colors, char *fmt, ...)
 {
 	int ret;
 	va_list args;
 
 	va_start(args, fmt);
-	ret = question(0, fmt, args);
+	ret = question(colors, 0, fmt, args);
 	va_end(args);
 
 	return(ret);
@@ -994,22 +1008,40 @@
 	ret = vasprintf(&msg, format, args);
 
 	/* print a prefix to the message */
-	switch(level) {
-		case PM_LOG_ERROR:
-			pm_asprintf(string, _("error: %s"), msg);
-			break;
-		case PM_LOG_WARNING:
-			pm_asprintf(string, _("warning: %s"), msg);
-			break;
-		case PM_LOG_DEBUG:
-			pm_asprintf(string, "debug: %s", msg);
-			break;
-		case PM_LOG_FUNCTION:
-			pm_asprintf(string, "function: %s", msg);
-			break;
-		default:
-			pm_asprintf(string, "%s", msg);
-			break;
+	if(isatty(fileno(stdout))) {
+		switch(level) {
+			case PM_LOG_DEBUG:
+				asprintf(string, "debug: %s", msg);
+				break;
+			case PM_LOG_ERROR:
+				asprintf(string, "%s%s%s%s", colortab.red, _("error: "), colortab.none, msg);
+				break;
+			case PM_LOG_WARNING:
+				asprintf(string, "%s%s%s%s", colortab.yellow, _("warning: "), colortab.none, msg);
+				break;
+			case PM_LOG_FUNCTION:
+				asprintf(string, _("function: %s"), msg);
+				break;
+			default:
+				break;
+		}
+	} else {
+		switch(level) {
+			case PM_LOG_DEBUG:
+				asprintf(string, "debug: %s", msg);
+				break;
+			case PM_LOG_ERROR:
+				asprintf(string, _("error: %s"), msg);
+				break;
+			case PM_LOG_WARNING:
+				asprintf(string, _("warning: %s"), msg);
+				break;
+			case PM_LOG_FUNCTION:
+				asprintf(string, _("function: %s"), msg);
+				break;
+			default:
+				break;
+		}
 	}
 	free(msg);
 
@@ -1044,10 +1076,10 @@
 	/* print a prefix to the message */
 	switch(level) {
 		case PM_LOG_ERROR:
-			fprintf(stream, _("error: "));
+			color_fprintf(stream, COLOR_RED_ALL, _("error: "));
 			break;
 		case PM_LOG_WARNING:
-			fprintf(stream, _("warning: "));
+			color_fprintf(stream, COLOR_YELLOW_ALL, _("warning: "));
 			break;
 		case PM_LOG_DEBUG:
 			fprintf(stream, "debug: ");
@@ -1086,4 +1118,310 @@
 }
 #endif
 
+/* pacman-color */
+
+int _set_color_sequence(const char* name, char* dest)
+{
+	int ret = 0;
+
+	if(strcmp(name, "black") == 0) {
+		strncpy(dest, "\033[0;30m", COLOR_LEN);
+	} else if(strcmp(name, "red") == 0) {
+		strncpy(dest, "\033[0;31m", COLOR_LEN);
+	} else if(strcmp(name, "green") == 0) {
+		strncpy(dest, "\033[0;32m", COLOR_LEN);
+	} else if(strcmp(name, "yellow") == 0) {
+		strncpy(dest, "\033[0;33m", COLOR_LEN);
+	} else if(strcmp(name, "blue") == 0) {
+		strncpy(dest, "\033[0;34m", COLOR_LEN);
+	} else if(strcmp(name, "magenta") == 0) {
+		strncpy(dest, "\033[0;35m", COLOR_LEN);
+	} else if(strcmp(name, "cyan") == 0) {
+		strncpy(dest, "\033[0;36m", COLOR_LEN);
+	} else if(strcmp(name, "white") == 0) {
+		strncpy(dest, "\033[0;37m", COLOR_LEN);
+	} else if(strcmp(name, "gray") == 0) {
+		strncpy(dest, "\033[1;30m", COLOR_LEN);
+	} else if(strcmp(name, "intensive red") == 0) {
+		strncpy(dest, "\033[1;31m", COLOR_LEN);
+	} else if(strcmp(name, "intensive green") == 0) {
+		strncpy(dest, "\033[1;32m", COLOR_LEN);
+	} else if(strcmp(name, "intensive yellow") == 0) {
+		strncpy(dest, "\033[1;33m", COLOR_LEN);
+	} else if(strcmp(name, "intensive blue") == 0) {
+		strncpy(dest, "\033[1;34m", COLOR_LEN);
+	} else if(strcmp(name, "intensive magenta") == 0) {
+		strncpy(dest, "\033[1;35m", COLOR_LEN);
+	} else if(strcmp(name, "intensive cyan") == 0) {
+		strncpy(dest, "\033[1;36m", COLOR_LEN);
+	} else if(strcmp(name, "intensive white") == 0) {
+		strncpy(dest, "\033[1;37m", COLOR_LEN);
+	} else if(strcmp(name, "intensive foreground") == 0) {
+		strncpy(dest, "\033[m\033[1m", COLOR_LEN);
+	} else if(strcmp(name, "none") == 0) {
+		strncpy(dest, "\033[m", COLOR_LEN);
+	} else {
+		ret = 1;
+	}
+	dest[COLOR_LEN] = '\0';
+	return(ret);
+}
+
+void _insert_color(FILE* stream, color_t color)
+{
+	switch(color) {
+		case COLOR_RED:
+			fprintf(stream, colortab.red);
+			break;
+		case COLOR_GREEN:
+			fprintf(stream, colortab.green);
+			break;
+		case COLOR_YELLOW:
+			fprintf(stream, colortab.yellow);
+			break;
+		case COLOR_BLUE:
+			fprintf(stream, colortab.blue);
+			break;
+		case COLOR_MAGENTA:
+			fprintf(stream, colortab.magenta);
+			break;
+		case COLOR_CYAN:
+			fprintf(stream, colortab.cyan);
+			break;
+		case COLOR_WHITE:
+			fprintf(stream, colortab.white);
+			break;
+		case COLOR_NONE:
+			fprintf(stream, colortab.none);
+			break;
+		default:;
+	}
+}
+
+int _parsecolorconfig(colortab_t* colortab, char* file)
+{
+	_set_color_sequence("intensive red", colortab->red);
+	_set_color_sequence("intensive green", colortab->green);
+	_set_color_sequence("intensive yellow", colortab->yellow);
+	_set_color_sequence("intensive blue", colortab->blue);
+	_set_color_sequence("intensive magenta", colortab->magenta);
+	_set_color_sequence("intensive cyan", colortab->cyan);
+	_set_color_sequence("intensive foreground", colortab->white);
+	_set_color_sequence("none", colortab->none);
+
+	FILE* fp = NULL;
+	int linenum = 0;
+	char line[PATH_MAX+1];
+	char* ptr;
+
+	fp = fopen(file, "r");
+	if(fp == NULL) {
+		pm_printf(PM_LOG_ERROR, _("config file %s could not be read.\n"), file);
+		return 1;
+	}
+	while(fgets(line, PATH_MAX, fp)) {
+		linenum++;
+		strtrim(line);
+
+		if(strlen(line) == 0 || line[0] == '#') {
+			continue;
+		}
+		if((ptr = strchr(line, '#'))) {
+			*ptr = '\0';
+		}
+
+		char* key = line;
+		ptr = line;
+		strsep(&ptr, "=");
+		strtrim(key);
+		strtrim(ptr);
+
+		if(key == NULL) {
+			pm_printf(PM_LOG_ERROR, _("config file %s, line %d: syntax error in config file- missing key.\n"),
+					file, linenum);
+			return 1;
+		}
+		if(strcmp(key, "Red") == 0) {
+			if(_set_color_sequence(ptr, colortab->red)) {
+				pm_printf(PM_LOG_ERROR, _("config file %s, line %d: color '%s' not recognized.\n"),
+							file, linenum, ptr);
+			}
+		} else if(strcmp(key, "Green") == 0) {
+			if(_set_color_sequence(ptr, colortab->green)) {
+				pm_printf(PM_LOG_ERROR, _("config file %s, line %d: color '%s' not recognized.\n"),
+							file, linenum, ptr);
+			}
+		} else if(strcmp(key, "Yellow") == 0) {
+			if(_set_color_sequence(ptr, colortab->yellow)) {
+				pm_printf(PM_LOG_ERROR, _("config file %s, line %d: color '%s' not recognized.\n"),
+							file, linenum, ptr);
+			}
+		} else if(strcmp(key, "Blue") == 0) {
+			if(_set_color_sequence(ptr, colortab->blue)) {
+				pm_printf(PM_LOG_ERROR, _("config file %s, line %d: color '%s' not recognized.\n"),
+							file, linenum, ptr);
+			}
+		} else if(strcmp(key, "Magenta") == 0) {
+			if(_set_color_sequence(ptr, colortab->magenta)) {
+				pm_printf(PM_LOG_ERROR, _("config file %s, line %d: color '%s' not recognized.\n"),
+							file, linenum, ptr);
+			}
+		} else if(strcmp(key, "Cyan") == 0) {
+			if(_set_color_sequence(ptr, colortab->cyan)) {
+				pm_printf(PM_LOG_ERROR, _("config file %s, line %d: color '%s' not recognized.\n"),
+							file, linenum, ptr);
+			}
+		} else if(strcmp(key, "White") == 0) {
+			if(_set_color_sequence(ptr, colortab->white)) {
+				pm_printf(PM_LOG_ERROR, _("config file %s, line %d: color '%s' not recognized.\n"),
+							file, linenum, ptr);
+			}
+		} else {
+			pm_printf(PM_LOG_ERROR, _("config file %s, line %d: directive '%s' not recognized.\n"),
+					file, linenum, key);
+			return(1);
+		}
+	}
+	return(0);
+}
+
+int parsecolorconfig()
+{
+	return(_parsecolorconfig(&colortab, "/etc/pacman.d/color.conf"));
+}
+
+int color_vfprintf(FILE* stream, const colordata_t* colors, const char* format, va_list args)
+{
+	int ret = 0;
+
+	if(isatty(fileno(stream)) && colors) {
+		char* msg = NULL;
+		ret = vasprintf(&msg, format, args);
+		if(msg == NULL) {
+			return(ret);
+		}
+
+		const colordata_t* colorpos = colors;
+		color_t colorlast = COLOR_NONE;
+		int len = strlen(msg) + 1;
+		wchar_t* wcstr = calloc(len, sizeof(wchar_t));
+		len = mbstowcs(wcstr, msg, len);
+		free(msg);
+		const wchar_t *strpos = wcstr;
+		
+		while(*strpos) {
+			if(colorpos->color != COLOR_END &&
+				((colorpos->separator == SEP_ANY) ||
+				 (colorpos->separator == SEP_LINE && *strpos == L'\n') ||
+				 (colorpos->separator == SEP_COLON && (*strpos == L':' || *strpos == L'：')))) {
+				_insert_color(stream, colorpos->color);
+				colorlast = colorpos->color;
+				colorpos++;
+			}
+			fprintf(stream, "%lc", (wint_t)*strpos);
+			strpos++;
+		}
+		free(wcstr);
+
+		if(colorlast != COLOR_NONE) {
+			_insert_color(stream, COLOR_NONE);
+		}
+	} else {
+		ret = vfprintf(stream, format, args);
+	}
+	return(ret);
+}
+
+int color_fprintf(FILE* stream, const colordata_t* colors, const char* format, ...)
+{
+	int ret;
+	va_list args;
+	va_start(args, format);
+	ret = color_vfprintf(stream, colors, format, args);
+	va_end(args);
+	return(ret);
+}
+
+int color_printf(const colordata_t* colors, const char* format, ...)
+{
+	int ret;
+	va_list args;
+	va_start(args, format);
+	ret = color_vfprintf(stdout, colors, format, args);
+	va_end(args);
+	return(ret);
+}
+
+void color_string_display(const colordata_t* colors_title, const char* title, const colordata_t* colors_string, const char* string)
+{
+	if(title) {
+		color_printf(colors_title, "%s ", title);
+	}
+	if(string == NULL || string[0] == '\0') {
+		printf(_("None"));
+	} else {
+		color_printf(colors_string, "%s", string);
+	}
+	printf("\n");
+}
+
+const colordata_t COLOR_WHITE_ALL[] = {
+	{ SEP_ANY, COLOR_WHITE },
+	{ SEP_LINE, COLOR_NONE },
+	{ SEP_ANY, COLOR_END } };
+
+const colordata_t COLOR_GREEN_ALL[] = {
+	{ SEP_ANY, COLOR_GREEN },
+	{ SEP_LINE, COLOR_NONE },
+	{ SEP_ANY, COLOR_END } };
+
+const colordata_t COLOR_RED_ALL[] = {
+	{ SEP_ANY, COLOR_RED },
+	{ SEP_LINE, COLOR_NONE },
+	{ SEP_ANY, COLOR_END } };
+
+const colordata_t COLOR_BLUE_ALL[] = {
+	{ SEP_ANY, COLOR_BLUE },
+	{ SEP_LINE, COLOR_NONE },
+	{ SEP_ANY, COLOR_END } };
+
+const colordata_t COLOR_YELLOW_ALL[] = {
+	{ SEP_ANY, COLOR_YELLOW },
+	{ SEP_LINE, COLOR_NONE },
+	{ SEP_ANY, COLOR_END } };
+
+const colordata_t COLOR_MAGENTA_ALL[] = {
+	{ SEP_ANY, COLOR_MAGENTA },
+	{ SEP_LINE, COLOR_NONE },
+	{ SEP_ANY, COLOR_END } };
+
+const colordata_t COLOR_CYAN_ALL[] = {
+	{ SEP_ANY, COLOR_CYAN },
+	{ SEP_LINE, COLOR_NONE },
+	{ SEP_ANY, COLOR_END } };
+
+const colordata_t COLOR_DOUBLECOLON[] = {
+	{ SEP_ANY, COLOR_BLUE },
+	{ SEP_ANY, COLOR_SAME },
+	{ SEP_ANY, COLOR_WHITE },
+	{ SEP_LINE, COLOR_NONE },
+	{ SEP_ANY, COLOR_END } };
+
+const colordata_t COLOR_DOUBLECOLON2[] = {
+	{ SEP_ANY, COLOR_BLUE },
+	{ SEP_ANY, COLOR_SAME },
+	{ SEP_ANY, COLOR_WHITE },
+	{ SEP_LINE, COLOR_NONE },
+	{ SEP_ANY, COLOR_BLUE },
+	{ SEP_ANY, COLOR_SAME },
+	{ SEP_ANY, COLOR_WHITE },
+	{ SEP_LINE, COLOR_NONE },
+	{ SEP_ANY, COLOR_END } };
+
+const colordata_t COLOR_WHITE_COLON[] = {
+	{ SEP_ANY, COLOR_WHITE },
+	{ SEP_COLON, COLOR_SAME },
+	{ SEP_ANY, COLOR_NONE },
+	{ SEP_ANY, COLOR_END } };
+
 /* vim: set ts=2 sw=2 noet: */
diff -Naur pacman-3.5.2//src/pacman/util.c.orig pacman-color-3.5.2//src/pacman/util.c.orig
--- pacman-3.5.2//src/pacman/util.c.orig	1970-01-01 01:00:00.000000000 +0100
+++ pacman-color-3.5.2//src/pacman/util.c.orig	2011-04-05 02:03:27.000000000 +0200
@@ -0,0 +1,1089 @@
+/*
+ *  util.c
+ *
+ *  Copyright (c) 2006-2011 Pacman Development Team <pacman-dev@archlinux.org>
+ *  Copyright (c) 2002-2006 by Judd Vinet <jvinet@zeroflux.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "config.h"
+
+#include <sys/types.h>
+#include <sys/ioctl.h>
+#include <sys/stat.h>
+#include <sys/time.h>
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdarg.h>
+#include <stdint.h> /* intmax_t */
+#include <string.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <ctype.h>
+#include <dirent.h>
+#include <unistd.h>
+#include <limits.h>
+#include <wchar.h>
+
+#include <alpm.h>
+#include <alpm_list.h>
+
+/* pacman */
+#include "util.h"
+#include "conf.h"
+#include "callback.h"
+
+
+int trans_init(pmtransflag_t flags)
+{
+	int ret;
+	if(config->print) {
+		ret = alpm_trans_init(flags, NULL, NULL, NULL);
+	} else {
+		ret = alpm_trans_init(flags, cb_trans_evt, cb_trans_conv,
+				cb_trans_progress);
+	}
+
+	if(ret == -1) {
+		pm_fprintf(stderr, PM_LOG_ERROR, _("failed to init transaction (%s)\n"),
+				alpm_strerrorlast());
+		if(pm_errno == PM_ERR_HANDLE_LOCK) {
+			fprintf(stderr, _("  if you're sure a package manager is not already\n"
+						"  running, you can remove %s\n"), alpm_option_get_lockfile());
+		}
+		else if(pm_errno == PM_ERR_DB_VERSION) {
+			fprintf(stderr, _("  try running pacman-db-upgrade\n"));
+		}
+
+		return(-1);
+	}
+	return(0);
+}
+
+int trans_release(void)
+{
+	if(alpm_trans_release() == -1) {
+		pm_fprintf(stderr, PM_LOG_ERROR, _("failed to release transaction (%s)\n"),
+				alpm_strerrorlast());
+		return(-1);
+	}
+	return(0);
+}
+
+int needs_root(void)
+{
+	switch(config->op) {
+		case PM_OP_DATABASE:
+			return(1);
+		case PM_OP_UPGRADE:
+		case PM_OP_REMOVE:
+			return(!config->print);
+		case PM_OP_SYNC:
+			return(config->op_s_clean || config->op_s_sync ||
+					(!config->group && !config->op_s_info && !config->op_q_list &&
+					 !config->op_s_search && !config->print));
+		default:
+			return(0);
+	}
+}
+
+/* gets the current screen column width */
+int getcols(void)
+{
+#ifdef TIOCGSIZE
+	struct ttysize win;
+	if(ioctl(1, TIOCGSIZE, &win) == 0) {
+		return win.ts_cols;
+	}
+#elif defined(TIOCGWINSZ)
+	struct winsize win;
+	if(ioctl(1, TIOCGWINSZ, &win) == 0) {
+		return win.ws_col;
+	}
+#endif
+	return 0;
+}
+
+/* does the same thing as 'rm -rf' */
+int rmrf(const char *path)
+{
+	int errflag = 0;
+	struct dirent *dp;
+	DIR *dirp;
+
+	if(!unlink(path)) {
+		return(0);
+	} else {
+		if(errno == ENOENT) {
+			return(0);
+		} else if(errno == EPERM) {
+			/* fallthrough */
+		} else if(errno == EISDIR) {
+			/* fallthrough */
+		} else if(errno == ENOTDIR) {
+			return(1);
+		} else {
+			/* not a directory */
+			return(1);
+		}
+
+		dirp = opendir(path);
+		if(!dirp) {
+			return(1);
+		}
+		for(dp = readdir(dirp); dp != NULL; dp = readdir(dirp)) {
+			if(dp->d_ino) {
+				char name[PATH_MAX];
+				sprintf(name, "%s/%s", path, dp->d_name);
+				if(strcmp(dp->d_name, "..") != 0 && strcmp(dp->d_name, ".") != 0) {
+					errflag += rmrf(name);
+				}
+			}
+		}
+		closedir(dirp);
+		if(rmdir(path)) {
+			errflag++;
+		}
+		return(errflag);
+	}
+}
+
+/** Parse the basename of a program from a path.
+* @param path path to parse basename from
+*
+* @return everything following the final '/'
+*/
+const char *mbasename(const char *path)
+{
+	const char *last = strrchr(path, '/');
+	if(last) {
+		return(last + 1);
+	}
+	return(path);
+}
+
+/** Parse the dirname of a program from a path.
+* The path returned should be freed.
+* @param path path to parse dirname from
+*
+* @return everything preceding the final '/'
+*/
+char *mdirname(const char *path)
+{
+	char *ret, *last;
+
+	/* null or empty path */
+	if(path == NULL || path == '\0') {
+		return(strdup("."));
+	}
+
+	ret = strdup(path);
+	last = strrchr(ret, '/');
+
+	if(last != NULL) {
+		/* we found a '/', so terminate our string */
+		*last = '\0';
+		return(ret);
+	}
+	/* no slash found */
+	free(ret);
+	return(strdup("."));
+}
+
+/* output a string, but wrap words properly with a specified indentation
+ */
+void indentprint(const char *str, int indent)
+{
+	wchar_t *wcstr;
+	const wchar_t *p;
+	int len, cidx, cols;
+
+	if(!str) {
+		return;
+	}
+
+	cols = getcols();
+
+	/* if we're not a tty, print without indenting */
+	if(cols == 0) {
+		printf("%s", str);
+		return;
+	}
+
+	len = strlen(str) + 1;
+	wcstr = calloc(len, sizeof(wchar_t));
+	len = mbstowcs(wcstr, str, len);
+	p = wcstr;
+	cidx = indent;
+
+	if(!p || !len) {
+		return;
+	}
+
+	while(*p) {
+		if(*p == L' ') {
+			const wchar_t *q, *next;
+			p++;
+			if(p == NULL || *p == L' ') continue;
+			next = wcschr(p, L' ');
+			if(next == NULL) {
+				next = p + wcslen(p);
+			}
+			/* len captures # cols */
+			len = 0;
+			q = p;
+			while(q < next) {
+				len += wcwidth(*q++);
+			}
+			if(len > (cols - cidx - 1)) {
+				/* wrap to a newline and reindent */
+				printf("\n%-*s", indent, "");
+				cidx = indent;
+			} else {
+				printf(" ");
+				cidx++;
+			}
+			continue;
+		}
+		printf("%lc", (wint_t)*p);
+		cidx += wcwidth(*p);
+		p++;
+	}
+	free(wcstr);
+}
+
+/* Convert a string to uppercase
+ */
+char *strtoupper(char *str)
+{
+	char *ptr = str;
+
+	while(*ptr) {
+		(*ptr) = (char)toupper((unsigned char)*ptr);
+		ptr++;
+	}
+	return str;
+}
+
+/* Trim whitespace and newlines from a string
+ */
+char *strtrim(char *str)
+{
+	char *pch = str;
+
+	if(str == NULL || *str == '\0') {
+		/* string is empty, so we're done. */
+		return(str);
+	}
+
+	while(isspace((unsigned char)*pch)) {
+		pch++;
+	}
+	if(pch != str) {
+		memmove(str, pch, (strlen(pch) + 1));
+	}
+
+	/* check if there wasn't anything but whitespace in the string. */
+	if(*str == '\0') {
+		return(str);
+	}
+
+	pch = (str + (strlen(str) - 1));
+	while(isspace((unsigned char)*pch)) {
+		pch--;
+	}
+	*++pch = '\0';
+
+	return(str);
+}
+
+/* Replace all occurances of 'needle' with 'replace' in 'str', returning
+ * a new string (must be free'd) */
+char *strreplace(const char *str, const char *needle, const char *replace)
+{
+	const char *p = NULL, *q = NULL;
+	char *newstr = NULL, *newp = NULL;
+	alpm_list_t *i = NULL, *list = NULL;
+	size_t needlesz = strlen(needle), replacesz = strlen(replace);
+	size_t newsz;
+
+	if(!str) {
+		return(NULL);
+	}
+
+	p = str;
+	q = strstr(p, needle);
+	while(q) {
+		list = alpm_list_add(list, (char *)q);
+		p = q + needlesz;
+		q = strstr(p, needle);
+	}
+
+	/* no occurences of needle found */
+	if(!list) {
+		return(strdup(str));
+	}
+	/* size of new string = size of old string + "number of occurences of needle"
+	 * x "size difference between replace and needle" */
+	newsz = strlen(str) + 1 +
+		alpm_list_count(list) * (replacesz - needlesz);
+	newstr = malloc(newsz);
+	if(!newstr) {
+		return(NULL);
+	}
+	*newstr = '\0';
+
+	p = str;
+	newp = newstr;
+	for(i = list; i; i = alpm_list_next(i)) {
+		q = alpm_list_getdata(i);
+		if(q > p){
+			/* add chars between this occurence and last occurence, if any */
+			strncpy(newp, p, (size_t)(q - p));
+			newp += q - p;
+		}
+		strncpy(newp, replace, replacesz);
+		newp += replacesz;
+		p = q + needlesz;
+	}
+	alpm_list_free(list);
+
+	if(*p) {
+		/* add the rest of 'p' */
+		strcpy(newp, p);
+		newp += strlen(p);
+	}
+	*newp = '\0';
+
+	return(newstr);
+}
+
+/** Splits a string into a list of strings using the chosen character as
+ * a delimiter.
+ *
+ * @param str the string to split
+ * @param splitchar the character to split at
+ *
+ * @return a list containing the duplicated strings
+ */
+alpm_list_t *strsplit(const char *str, const char splitchar)
+{
+	alpm_list_t *list = NULL;
+	const char *prev = str;
+	char *dup = NULL;
+
+	while((str = strchr(str, splitchar))) {
+		dup = strndup(prev, (size_t)(str - prev));
+		if(dup == NULL) {
+			return(NULL);
+		}
+		list = alpm_list_add(list, dup);
+
+		str++;
+		prev = str;
+	}
+
+	dup = strdup(prev);
+	if(dup == NULL) {
+		return(NULL);
+	}
+	list = alpm_list_add(list, dup);
+
+	return(list);
+}
+
+static int string_length(const char *s)
+{
+	int len;
+	wchar_t *wcstr;
+
+	if(!s) {
+		return(0);
+	}
+	/* len goes from # bytes -> # chars -> # cols */
+	len = strlen(s) + 1;
+	wcstr = calloc(len, sizeof(wchar_t));
+	len = mbstowcs(wcstr, s, len);
+	len = wcswidth(wcstr, len);
+	free(wcstr);
+
+	return(len);
+}
+
+void string_display(const char *title, const char *string)
+{
+	int len = 0;
+
+	if(title) {
+		printf("%s ", title);
+	}
+	if(string == NULL || string[0] == '\0') {
+		printf(_("None"));
+	} else {
+		/* compute the length of title + a space */
+		len = string_length(title) + 1;
+		indentprint(string, len);
+	}
+	printf("\n");
+}
+
+void list_display(const char *title, const alpm_list_t *list)
+{
+	const alpm_list_t *i;
+	int cols, len = 0;
+
+	if(title) {
+		len = string_length(title) + 1;
+		printf("%s ", title);
+	}
+
+	if(!list) {
+		printf("%s\n", _("None"));
+	} else {
+		for(i = list, cols = len; i; i = alpm_list_next(i)) {
+			char *str = alpm_list_getdata(i);
+			int s = string_length(str);
+			int maxcols = getcols();
+			if(maxcols > 0 && (cols + s + 2) >= maxcols) {
+				int j;
+				cols = len;
+				printf("\n");
+				for (j = 1; j <= len; j++) {
+					printf(" ");
+				}
+			} else if (cols != len) {
+				/* 2 spaces are added if this is not the first element on a line. */
+				printf("  ");
+				cols += 2;
+			}
+			printf("%s", str);
+			cols += s;
+		}
+		printf("\n");
+	}
+}
+
+void list_display_linebreak(const char *title, const alpm_list_t *list)
+{
+	const alpm_list_t *i;
+	int len = 0;
+
+	if(title) {
+		len = string_length(title) + 1;
+		printf("%s ", title);
+	}
+
+	if(!list) {
+		printf("%s\n", _("None"));
+	} else {
+		/* Print the first element */
+		indentprint((const char *) alpm_list_getdata(list), len);
+		printf("\n");
+		/* Print the rest */
+		for(i = alpm_list_next(list); i; i = alpm_list_next(i)) {
+			int j;
+			for(j = 1; j <= len; j++) {
+				printf(" ");
+			}
+			indentprint((const char *) alpm_list_getdata(i), len);
+			printf("\n");
+		}
+	}
+}
+/* prepare a list of pkgs to display */
+void display_targets(const alpm_list_t *pkgs, int install)
+{
+	char *str;
+	const alpm_list_t *i;
+	off_t isize = 0, dlsize = 0;
+	double mbisize = 0.0, mbdlsize = 0.0;
+	alpm_list_t *targets = NULL;
+
+	if(!pkgs) {
+		return;
+	}
+
+	printf("\n");
+	for(i = pkgs; i; i = alpm_list_next(i)) {
+		pmpkg_t *pkg = alpm_list_getdata(i);
+
+		if(install) {
+			dlsize += alpm_pkg_download_size(pkg);
+		}
+		isize += alpm_pkg_get_isize(pkg);
+
+		/* print the package size with the output if ShowSize option set */
+		if(config->showsize) {
+			double mbsize = (double)alpm_pkg_get_size(pkg) / (1024.0 * 1024.0);
+
+			pm_asprintf(&str, "%s-%s [%.2f MB]", alpm_pkg_get_name(pkg),
+					alpm_pkg_get_version(pkg), mbsize);
+		} else {
+			pm_asprintf(&str, "%s-%s", alpm_pkg_get_name(pkg),
+					alpm_pkg_get_version(pkg));
+		}
+		targets = alpm_list_add(targets, str);
+	}
+
+	/* Convert byte sizes to MB */
+	mbdlsize = (double)dlsize / (1024.0 * 1024.0);
+	mbisize = (double)isize / (1024.0 * 1024.0);
+
+	if(install) {
+		pm_asprintf(&str, _("Targets (%d):"), alpm_list_count(targets));
+		list_display(str, targets);
+		free(str);
+		printf("\n");
+
+		printf(_("Total Download Size:    %.2f MB\n"), mbdlsize);
+		if(!(config->flags & PM_TRANS_FLAG_DOWNLOADONLY)) {
+			printf(_("Total Installed Size:   %.2f MB\n"), mbisize);
+		}
+	} else {
+		pm_asprintf(&str, _("Remove (%d):"), alpm_list_count(targets));
+		list_display(str, targets);
+		free(str);
+		printf("\n");
+
+		printf(_("Total Removed Size:   %.2f MB\n"), mbisize);
+	}
+
+	FREELIST(targets);
+}
+
+static off_t pkg_get_size(pmpkg_t *pkg)
+{
+	switch(config->op) {
+		case PM_OP_SYNC:
+			return(alpm_pkg_download_size(pkg));
+		case PM_OP_UPGRADE:
+			return(alpm_pkg_get_size(pkg));
+		default:
+			return(alpm_pkg_get_isize(pkg));
+	}
+}
+
+static char *pkg_get_location(pmpkg_t *pkg)
+{
+	pmdb_t *db;
+	const char *dburl;
+	char *string;
+	switch(config->op) {
+		case PM_OP_SYNC:
+			db = alpm_pkg_get_db(pkg);
+			dburl = alpm_db_get_url(db);
+			if(dburl) {
+				char *pkgurl = NULL;
+				pm_asprintf(&pkgurl, "%s/%s", dburl, alpm_pkg_get_filename(pkg));
+				return(pkgurl);
+			}
+		case PM_OP_UPGRADE:
+			return(strdup(alpm_pkg_get_filename(pkg)));
+		default:
+			string = NULL;
+			pm_asprintf(&string, "%s-%s", alpm_pkg_get_name(pkg), alpm_pkg_get_version(pkg));
+			return(string);
+	}
+}
+
+void print_packages(const alpm_list_t *packages)
+{
+	const alpm_list_t *i;
+	if(!config->print_format) {
+		config->print_format = strdup("%l");
+	}
+	for(i = packages; i; i = alpm_list_next(i)) {
+		pmpkg_t *pkg = alpm_list_getdata(i);
+		char *string = strdup(config->print_format);
+		char *temp = string;
+		/* %n : pkgname */
+		if(strstr(temp,"%n")) {
+			string = strreplace(temp, "%n", alpm_pkg_get_name(pkg));
+			free(temp);
+			temp = string;
+		}
+		/* %v : pkgver */
+		if(strstr(temp,"%v")) {
+			string = strreplace(temp, "%v", alpm_pkg_get_version(pkg));
+			free(temp);
+			temp = string;
+		}
+		/* %l : location */
+		if(strstr(temp,"%l")) {
+			char *pkgloc = pkg_get_location(pkg);
+			string = strreplace(temp, "%l", pkgloc);
+			free(pkgloc);
+			free(temp);
+			temp = string;
+		}
+		/* %r : repo */
+		if(strstr(temp,"%r")) {
+			const char *repo = "local";
+			pmdb_t *db = alpm_pkg_get_db(pkg);
+			if(db) {
+				repo = alpm_db_get_name(db);
+			}
+			string = strreplace(temp, "%r", repo);
+			free(temp);
+			temp = string;
+		}
+		/* %s : size */
+		if(strstr(temp,"%s")) {
+			char *size;
+			pm_asprintf(&size, "%jd", (intmax_t)pkg_get_size(pkg));
+			string = strreplace(temp, "%s", size);
+			free(size);
+			free(temp);
+		}
+		printf("%s\n",string);
+		free(string);
+	}
+}
+
+/* Helper function for comparing strings using the
+ * alpm "compare func" signature */
+int str_cmp(const void *s1, const void *s2)
+{
+	return(strcmp(s1, s2));
+}
+
+void display_new_optdepends(pmpkg_t *oldpkg, pmpkg_t *newpkg)
+{
+	alpm_list_t *old = alpm_pkg_get_optdepends(oldpkg);
+	alpm_list_t *new = alpm_pkg_get_optdepends(newpkg);
+	alpm_list_t *optdeps = alpm_list_diff(new,old,str_cmp);
+	if(optdeps) {
+		printf(_("New optional dependencies for %s\n"), alpm_pkg_get_name(newpkg));
+		list_display_linebreak("   ", optdeps);
+	}
+	alpm_list_free(optdeps);
+}
+
+void display_optdepends(pmpkg_t *pkg)
+{
+	alpm_list_t *optdeps = alpm_pkg_get_optdepends(pkg);
+	if(optdeps) {
+		printf(_("Optional dependencies for %s\n"), alpm_pkg_get_name(pkg));
+		list_display_linebreak("   ", optdeps);
+	}
+}
+
+static void display_repo_list(const char *dbname, alpm_list_t *list)
+{
+	const char *prefix= "  ";
+
+	printf(":: ");
+	printf(_("Repository %s\n"), dbname);
+	list_display(prefix, list);
+}
+
+void select_display(const alpm_list_t *pkglist)
+{
+	const alpm_list_t *i;
+	int nth = 1;
+	alpm_list_t *list = NULL;
+	char *string = NULL;
+	const char *dbname = NULL;
+
+	for (i = pkglist; i; i = i->next) {
+		pmpkg_t *pkg = alpm_list_getdata(i);
+		pmdb_t *db = alpm_pkg_get_db(pkg);
+
+		if(!dbname)
+			dbname = alpm_db_get_name(db);
+		if(strcmp(alpm_db_get_name(db), dbname) != 0) {
+			display_repo_list(dbname, list);
+			FREELIST(list);
+			dbname = alpm_db_get_name(db);
+		}
+		string = NULL;
+		pm_asprintf(&string, "%d) %s", nth, alpm_pkg_get_name(pkg));
+		list = alpm_list_add(list, string);
+		nth++;
+	}
+	display_repo_list(dbname, list);
+	FREELIST(list);
+}
+
+static int parseindex(char *s, int *val, int min, int max)
+{
+	char *endptr = NULL;
+	int n = strtol(s, &endptr, 10);
+	if(*endptr == '\0') {
+		if(n < min || n > max) {
+			fprintf(stderr, _("Invalid value: %d is not between %d and %d\n"),
+					n, min, max);
+			return(-1);
+		}
+		*val = n;
+		return(0);
+	} else {
+		fprintf(stderr, _("Invalid number: %s\n"), s);
+		return(-1);
+	}
+}
+
+static int multiselect_parse(char *array, int count, char *response)
+{
+	char *str, *saveptr;
+
+	for (str = response; ; str = NULL) {
+		int include = 1;
+		int start, end;
+		char *ends = NULL;
+		char *starts = strtok_r(str, " ", &saveptr);
+
+		if (starts == NULL) {
+			break;
+		}
+		strtrim(starts);
+		int len = strlen(starts);
+		if(len == 0)
+			continue;
+
+		if (*starts == '^') {
+			starts++;
+			len--;
+			include = 0;
+		} else if(str) {
+			/* if first token is including, we unselect all targets */
+			memset(array, 0, count);
+		}
+
+		if(len > 1) {
+			/* check for range */
+			char *p;
+			if((p = strchr(starts + 1, '-'))) {
+				*p = 0;
+				ends = p + 1;
+			}
+		}
+
+		if(parseindex(starts, &start, 1, count) != 0)
+			return(-1);
+
+		if(!ends) {
+			array[start-1] = include;
+		} else {
+			int d;
+			if(parseindex(ends, &end, start, count) != 0) {
+				return(-1);
+			}
+			for(d = start; d <= end; d++) {
+				array[d-1] = include;
+			}
+		}
+	}
+
+	return(0);
+}
+
+int multiselect_question(char *array, int count)
+{
+	char response[64];
+	FILE *stream;
+
+	if(config->noconfirm) {
+		stream = stdout;
+	} else {
+		/* Use stderr so questions are always displayed when redirecting output */
+		stream = stderr;
+	}
+
+	while(1) {
+		memset(array, 1, count);
+
+		fprintf(stream, "\n");
+		fprintf(stream, _("Enter a selection (default=all)"));
+		fprintf(stream,	": ");
+
+		if(config->noconfirm) {
+			fprintf(stream, "\n");
+			break;
+		}
+
+		if(fgets(response, sizeof(response), stdin)) {
+			strtrim(response);
+			if(strlen(response) > 0) {
+				if(multiselect_parse(array, count, response) == -1) {
+					/* only loop if user gave an invalid answer */
+					continue;
+				}
+			}
+		}
+		break;
+	}
+	return(0);
+}
+
+int select_question(int count)
+{
+	char response[32];
+	FILE *stream;
+	int preset = 1;
+
+	if(config->noconfirm) {
+		stream = stdout;
+	} else {
+		/* Use stderr so questions are always displayed when redirecting output */
+		stream = stderr;
+	}
+
+	while(1) {
+		fprintf(stream, "\n");
+		fprintf(stream, _("Enter a number (default=%d)"), preset);
+		fprintf(stream,	": ");
+
+		if(config->noconfirm) {
+			fprintf(stream, "\n");
+			break;
+		}
+
+		if(fgets(response, sizeof(response), stdin)) {
+			strtrim(response);
+			if(strlen(response) > 0) {
+				int n;
+				if(parseindex(response, &n, 1, count) != 0)
+					continue;
+				return(n-1);
+			}
+		}
+		break;
+	}
+
+	return(preset-1);
+}
+
+
+/* presents a prompt and gets a Y/N answer */
+static int question(short preset, char *fmt, va_list args)
+{
+	char response[32];
+	FILE *stream;
+
+	if(config->noconfirm) {
+		stream = stdout;
+	} else {
+		/* Use stderr so questions are always displayed when redirecting output */
+		stream = stderr;
+	}
+
+	/* ensure all text makes it to the screen before we prompt the user */
+	fflush(stdout);
+	fflush(stderr);
+
+	vfprintf(stream, fmt, args);
+
+	if(preset) {
+		fprintf(stream, " %s ", _("[Y/n]"));
+	} else {
+		fprintf(stream, " %s ", _("[y/N]"));
+	}
+
+	if(config->noconfirm) {
+		fprintf(stream, "\n");
+		return(preset);
+	}
+
+	fflush(stream);
+	if(fgets(response, sizeof(response), stdin)) {
+		strtrim(response);
+		if(strlen(response) == 0) {
+			return(preset);
+		}
+
+		if(strcasecmp(response, _("Y")) == 0 || strcasecmp(response, _("YES")) == 0) {
+			return(1);
+		} else if (strcasecmp(response, _("N")) == 0 || strcasecmp(response, _("NO")) == 0) {
+			return(0);
+		}
+	}
+	return(0);
+}
+
+int yesno(char *fmt, ...)
+{
+	int ret;
+	va_list args;
+
+	va_start(args, fmt);
+	ret = question(1, fmt, args);
+	va_end(args);
+
+	return(ret);
+}
+
+int noyes(char *fmt, ...)
+{
+	int ret;
+	va_list args;
+
+	va_start(args, fmt);
+	ret = question(0, fmt, args);
+	va_end(args);
+
+	return(ret);
+}
+
+int pm_printf(pmloglevel_t level, const char *format, ...)
+{
+	int ret;
+	va_list args;
+
+	/* print the message using va_arg list */
+	va_start(args, format);
+	ret = pm_vfprintf(stdout, level, format, args);
+	va_end(args);
+
+	return(ret);
+}
+
+int pm_fprintf(FILE *stream, pmloglevel_t level, const char *format, ...)
+{
+	int ret;
+	va_list args;
+
+	/* print the message using va_arg list */
+	va_start(args, format);
+	ret = pm_vfprintf(stream, level, format, args);
+	va_end(args);
+
+	return(ret);
+}
+
+int pm_asprintf(char **string, const char *format, ...)
+{
+	int ret = 0;
+	va_list args;
+
+	/* print the message using va_arg list */
+	va_start(args, format);
+	if(vasprintf(string, format, args) == -1) {
+		pm_fprintf(stderr, PM_LOG_ERROR,  _("failed to allocate string\n"));
+		ret = -1;
+	}
+	va_end(args);
+
+	return(ret);
+}
+
+int pm_vasprintf(char **string, pmloglevel_t level, const char *format, va_list args)
+{
+	int ret = 0;
+	char *msg = NULL;
+
+	/* if current logmask does not overlap with level, do not print msg */
+	if(!(config->logmask & level)) {
+		return ret;
+	}
+
+	/* print the message using va_arg list */
+	ret = vasprintf(&msg, format, args);
+
+	/* print a prefix to the message */
+	switch(level) {
+		case PM_LOG_ERROR:
+			pm_asprintf(string, _("error: %s"), msg);
+			break;
+		case PM_LOG_WARNING:
+			pm_asprintf(string, _("warning: %s"), msg);
+			break;
+		case PM_LOG_DEBUG:
+			pm_asprintf(string, "debug: %s", msg);
+			break;
+		case PM_LOG_FUNCTION:
+			pm_asprintf(string, "function: %s", msg);
+			break;
+		default:
+			pm_asprintf(string, "%s", msg);
+			break;
+	}
+	free(msg);
+
+	return(ret);
+}
+
+int pm_vfprintf(FILE *stream, pmloglevel_t level, const char *format, va_list args)
+{
+	int ret = 0;
+
+	/* if current logmask does not overlap with level, do not print msg */
+	if(!(config->logmask & level)) {
+		return ret;
+	}
+
+#if defined(PACMAN_DEBUG)
+	/* If debug is on, we'll timestamp the output */
+	if(config->logmask & PM_LOG_DEBUG) {
+		time_t t;
+		struct tm *tmp;
+		char timestr[10] = {0};
+
+		t = time(NULL);
+		tmp = localtime(&t);
+		strftime(timestr, 9, "%H:%M:%S", tmp);
+		timestr[8] = '\0';
+
+		printf("[%s] ", timestr);
+	}
+#endif
+
+	/* print a prefix to the message */
+	switch(level) {
+		case PM_LOG_ERROR:
+			fprintf(stream, _("error: "));
+			break;
+		case PM_LOG_WARNING:
+			fprintf(stream, _("warning: "));
+			break;
+		case PM_LOG_DEBUG:
+			fprintf(stream, "debug: ");
+			break;
+		case PM_LOG_FUNCTION:
+			fprintf(stream, "function: ");
+			break;
+		default:
+			break;
+	}
+
+	/* print the message using va_arg list */
+	ret = vfprintf(stream, format, args);
+	return(ret);
+}
+
+#ifndef HAVE_STRNDUP
+/* A quick and dirty implementation derived from glibc */
+static size_t strnlen(const char *s, size_t max)
+{
+    register const char *p;
+    for(p = s; *p && max--; ++p);
+    return(p - s);
+}
+
+char *strndup(const char *s, size_t n)
+{
+  size_t len = strnlen(s, n);
+  char *new = (char *) malloc(len + 1);
+
+  if (new == NULL)
+    return NULL;
+
+  new[len] = '\0';
+  return (char *) memcpy(new, s, len);
+}
+#endif
+
+/* vim: set ts=2 sw=2 noet: */
diff -Naur pacman-3.5.2//src/pacman/util.h pacman-color-3.5.2//src/pacman/util.h
--- pacman-3.5.2//src/pacman/util.h	2011-02-28 18:13:17.000000000 +0100
+++ pacman-color-3.5.2//src/pacman/util.h	2011-04-19 17:21:28.000000000 +0200
@@ -39,6 +39,48 @@
 /* update speed for the fill_progress based functions */
 #define UPDATE_SPEED_SEC 0.2f
 
+/* pacman-color */
+typedef enum _separator_t {
+	SEP_ANY = 0,
+	SEP_LINE,
+	SEP_COLON,
+} separator_t;
+
+typedef enum _color_t {
+	COLOR_END = 0,
+	COLOR_SAME,
+	COLOR_RED,
+	COLOR_GREEN,
+	COLOR_YELLOW,
+	COLOR_BLUE,
+	COLOR_MAGENTA,
+	COLOR_CYAN,
+	COLOR_WHITE,
+	COLOR_NONE,
+} color_t;
+
+typedef struct _colordata_t {
+	separator_t separator;
+	color_t color;
+} colordata_t;
+
+extern const colordata_t COLOR_WHITE_ALL[];
+extern const colordata_t COLOR_GREEN_ALL[];
+extern const colordata_t COLOR_RED_ALL[];
+extern const colordata_t COLOR_BLUE_ALL[];
+extern const colordata_t COLOR_YELLOW_ALL[];
+extern const colordata_t COLOR_MAGENTA_ALL[];
+extern const colordata_t COLOR_CYAN_ALL[];
+extern const colordata_t COLOR_DOUBLECOLON[];
+extern const colordata_t COLOR_DOUBLECOLON2[];
+extern const colordata_t COLOR_WHITE_COLON[];
+
+int parsecolorconfig();
+int color_fprintf(FILE* stream, const colordata_t* colors, const char* format, ...) __attribute__((format(printf,3,4)));
+int color_printf(const colordata_t* colors, const char* format, ...) __attribute__((format(printf,2,3)));
+int color_vfprintf(FILE* stream, const colordata_t* colors, const char* format, va_list args) __attribute__((format(printf,3,0)));
+void color_string_display(const colordata_t* colors_title, const char* title, const colordata_t* colors_string, const char* string);
+
 int trans_init(pmtransflag_t flags);
 int trans_release(void);
 int needs_root(void);
@@ -51,9 +93,9 @@
 char *strtrim(char *str);
 char *strreplace(const char *str, const char *needle, const char *replace);
 alpm_list_t *strsplit(const char *str, const char splitchar);
-void string_display(const char *title, const char *string);
-void list_display(const char *title, const alpm_list_t *list);
-void list_display_linebreak(const char *title, const alpm_list_t *list);
+void string_display(const colordata_t *colors_title, const char *title, const char *string);
+void list_display(const colordata_t *colors_title, const char *title, const alpm_list_t *list);
+void list_display_linebreak(const colordata_t *colors_title, const char *title, const alpm_list_t *list);
 void display_targets(const alpm_list_t *pkgs, int install);
 int str_cmp(const void *s1, const void *s2);
 void display_new_optdepends(pmpkg_t *oldpkg, pmpkg_t *newpkg);
@@ -62,8 +104,8 @@
 void select_display(const alpm_list_t *pkglist);
 int select_question(int count);
 int multiselect_question(char *array, int count);
-int yesno(char *fmt, ...);
-int noyes(char *fmt, ...);
+int yesno(const colordata_t *colors, char *fmt, ...);
+int noyes(const colordata_t *colors, char *fmt, ...);
 int pm_printf(pmloglevel_t level, const char *format, ...) __attribute__((format(printf,2,3)));
 int pm_fprintf(FILE *stream, pmloglevel_t level, const char *format, ...) __attribute__((format(printf,3,4)));
 int pm_asprintf(char **string, const char *format, ...);
