--- a/par2repairer.cpp
+++ b/par2repairer.cpp
@@ -18,6 +18,10 @@
 //  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 
 #include "par2cmdline.h"
+#include <sys/types.h>
+#include <sys/time.h>
+#include <sys/resource.h>
+#include <sys/sysctl.h>
 
 #ifdef _MSC_VER
 #ifdef _DEBUG
@@ -27,6 +31,67 @@ static char THIS_FILE[]=__FILE__;
 #endif
 #endif
 
+// Multiple thread support
+
+static const unsigned int cMaxThreadsSupported = 8;
+
+struct RepairThreadParams
+{
+	Par2Repairer *This;
+	size_t blocklength;
+	u32 inputindex;
+	u32 aStartBlockNo;
+	u32 aEndBlockNo;
+};
+
+struct VerifySourceFileCollectionThreadParams
+{
+	Par2Repairer *This;
+	vector<Par2RepairerSourceFile*> *fileCollection;
+};
+
+struct VerifyExtraFileCollectionThreadParams
+{
+	Par2Repairer *This;
+	const list<CommandLine::ExtraFile> *fileCollection;
+};
+
+void *Par2Repairer::RepairMissingBlockRangeFunc (void *aParams)
+{
+	assert (aParams);
+	RepairThreadParams *lParams = (RepairThreadParams *) aParams;
+	lParams->This->RepairMissingBlockRange (lParams->blocklength, lParams->inputindex, 
+																					lParams->aStartBlockNo, lParams->aEndBlockNo);
+	free (aParams);		// Done with it
+	return NULL;
+}
+
+void *Par2Repairer::VerifySourceFileCollectionFunc (void *aParams)
+{
+	assert (aParams);
+  VerifySourceFileCollectionThreadParams *lParams = (VerifySourceFileCollectionThreadParams *) aParams;
+	bool lResult = lParams->This->VerifySourceFileCollection (*(lParams->fileCollection));
+	free (aParams);		// Done with it
+	return lResult ? (void *) 1 : NULL;
+}
+
+void *Par2Repairer::VerifyFilesInVerifyListFunc (void *aParams)
+{
+	assert (aParams);
+	Par2Repairer *lThis = (Par2Repairer *) aParams;
+	bool lResult = lThis->VerifyFilesInVerifyList ();
+	return lResult ? (void *) 1 : NULL;
+}
+
+void *Par2Repairer::VerifyExtraFileCollectionFunc (void *aParams)
+{
+	assert (aParams);
+  VerifyExtraFileCollectionThreadParams *lParams = (VerifyExtraFileCollectionThreadParams *) aParams;
+	bool lResult = lParams->This->VerifyExtraFileCollection (*(lParams->fileCollection));
+	free (aParams);		// Done with it
+	return lResult ? (void *) 1 : NULL;
+}
+
 Par2Repairer::Par2Repairer(void)
 {
   firstpacket = true;
@@ -50,6 +115,19 @@ Par2Repairer::Par2Repairer(void)
   outputbuffer = 0;
 
   noiselevel = CommandLine::nlNormal;
+	
+	// Some stuff for the multi-thread optimization
+  previouslyReportedProgress = 0;
+	pthread_mutex_init (&progressMutex, NULL);
+	pthread_mutex_init (&fileIteratorMutex, NULL);
+	// Go and find out the number of CPU's
+	int lName [2] = { CTL_HW, HW_NCPU };
+	size_t lLen = sizeof (numCPUs);
+	if (sysctl(lName, 2, &numCPUs, &lLen, NULL, 0) != 0)
+	{
+		assert (false);
+		numCPUs = 1;		// Default value if we have an error in sysctl
+	}
 }
 
 Par2Repairer::~Par2Repairer(void)
@@ -76,6 +154,9 @@ Par2Repairer::~Par2Repairer(void)
 
   delete mainpacket;
   delete creatorpacket;
+	
+	pthread_mutex_destroy (&progressMutex);
+	pthread_mutex_destroy (&fileIteratorMutex);
 }
 
 Result Par2Repairer::Process(const CommandLine &commandline, bool dorepair)
@@ -83,6 +164,9 @@ Result Par2Repairer::Process(const CommandLine &commandline, bool dorepair)
   // What noiselevel are we using
   noiselevel = commandline.GetNoiseLevel();
 
+  struct rlimit rlp;		// Need this to allow for enough file handles
+  int 	lFileHandlesNeeded;
+
   // Get filesnames from the command line
   string par2filename = commandline.GetParFilename();
   const list<CommandLine::ExtraFile> &extrafiles = commandline.GetExtraFiles();
@@ -110,6 +194,21 @@ Result Par2Repairer::Process(const CommandLine &commandline, bool dorepair)
   if (!CheckPacketConsistency())
     return eInsufficientCriticalData;
 
+  // It appears that during repair the program opens all files simultaneously.
+  // Suppose the maximum number of file handles is 256, this would mean you can have
+  // about 250 files in a par set. This can be too small, so adjust if necessary. */
+  if (getrlimit (RLIMIT_NOFILE, &rlp) != 0)
+    return eLogicError;
+
+  lFileHandlesNeeded = mainpacket->TotalFileCount() + 16;		// A few extra
+  if (rlp.rlim_cur < lFileHandlesNeeded)
+  {
+    rlp.rlim_cur = lFileHandlesNeeded;
+    if (setrlimit (RLIMIT_NOFILE, &rlp) != 0)
+      return eLogicError;
+    cout << "Increased file limit to " << lFileHandlesNeeded << endl;
+  }
+  
   // Use the information in the main packet to get the source files
   // into the correct order and determine their filenames
   if (!CreateSourceFileList())
@@ -201,6 +300,7 @@ Result Par2Repairer::Process(const CommandLine &commandline, bool dorepair)
 
         // Set the total amount of data to be processed.
         progress = 0;
+        this->previouslyReportedProgress = -10000000;	// Big negative
         totaldata = blocksize * sourceblockcount * (missingblockcount > 0 ? missingblockcount : 1);
 
         // Start at an offset of 0 within a block.
@@ -309,6 +409,8 @@ bool Par2Repairer::LoadPacketsFromFile(string filename)
     // Continue as long as there is at least enough for the packet header
     while (offset + sizeof(PACKET_HEADER) <= filesize)
     {
+      // Define MPDL to suppress the percentages, because it slows things down considerably.
+#ifndef MPDL
       if (noiselevel > CommandLine::nlQuiet)
       {
         // Update a progress indicator
@@ -320,7 +422,7 @@ bool Par2Repairer::LoadPacketsFromFile(string filename)
           progress = offset;
         }
       }
-
+#endif
       // Attempt to read the next packet header
       PACKET_HEADER header;
       if (!diskfile->Read(offset, &header, sizeof(header)))
@@ -1118,116 +1220,251 @@ bool Par2Repairer::VerifySourceFiles(void)
 
   sort(sortedfiles.begin(), sortedfiles.end(), SortSourceFilesByFileName);
 
-  // Start verifying the files
-  sf = sortedfiles.begin();
-  while (sf != sortedfiles.end())
+	// Now launch as many file verification threads as there are CPU's
+	sourceFileIterator = sortedfiles.begin();	// Do this before the threads start
+
+	pthread_t lSpawnedThreads [cMaxThreadsSupported];
+	unsigned int lNumSpawnedThreads = 0;
+  unsigned int lNumThreads = numCPUs;
+	if (lNumThreads > cMaxThreadsSupported)
+		lNumThreads = cMaxThreadsSupported;
+
+	for (unsigned int lThreadNo = 0; lThreadNo < lNumThreads; lThreadNo++)
+	{
+		// Pass the address of the sortedfiles vector directly to the thread. We guarantee that
+		// the address remains valid as long as the thread runs.
+		VerifySourceFileCollectionThreadParams *lThreadParams = 
+				(VerifySourceFileCollectionThreadParams *) malloc (sizeof (VerifySourceFileCollectionThreadParams));
+		if (!lThreadParams)
+		{
+			finalresult = false;
+			break;	// From the for loop
+		}
+		lThreadParams->This = this;
+		lThreadParams->fileCollection = &sortedfiles;
+		int lResult = pthread_create (lSpawnedThreads + lThreadNo, NULL,
+																	Par2Repairer::VerifySourceFileCollectionFunc, lThreadParams);
+		if (lResult == 0)
+			lNumSpawnedThreads++;
+		else
+		{
+			// This is an error; don't start any more threads
+			finalresult = false;
+			break;	// From the for loop
+		}
+	}
+	// OK, we started all; now wait till all spawned threads have finished. The return value of
+	// each thread determines our return value: we AND it with finalresult, so in order to return
+	// true, all operations must succeed.
+	for (unsigned int lThreadNo = 0; lThreadNo < lNumSpawnedThreads; lThreadNo++)
+	{
+		void *lThreadResult;
+		int lResult = pthread_join(lSpawnedThreads [lThreadNo], &lThreadResult);
+		assert (lResult == 0);
+		finalresult = finalresult && (lThreadResult != NULL);
+	}
+	
+  return finalresult;
+}
+
+/* Function to allow for multi-thread verification of the source files.
+   The function can be called by multiple threads of execution; the threads
+   share the same collection of source files. They also share one iterator, 
+   which is an instance variable (sourceFileIterator), and which already has
+   been initialized at the start of the collection before the first of the 
+   threads starts. Each thread handles one complete file, then increments
+   the iterator and handles the "next" file.
+*/
+bool Par2Repairer::VerifySourceFileCollection (const vector<Par2RepairerSourceFile*> &aCollection)
+{
+	bool rv = true;
+	pthread_mutex_lock (&fileIteratorMutex);
+	
+  while (sourceFileIterator != aCollection.end())
   {
     // Do we have a source file
-    Par2RepairerSourceFile *sourcefile = *sf;
-
+    Par2RepairerSourceFile *sourcefile = *sourceFileIterator++;
+		
     // What filename does the file use
     string filename = sourcefile->TargetFileName();
-
+		
     // Check to see if we have already used this file
     if (diskFileMap.Find(filename) != 0)
     {
       // The file has already been used!
-
-      cerr << "Source file " << filenumber+1 << " is a duplicate." << endl;
-
-      return false;
+			
+      cerr << "Source file \"" << filename.c_str () << "\" is a duplicate." << endl;
+			rv = false;
+			break;
     }
-
+		
     DiskFile *diskfile = new DiskFile;
-
+		
     // Does the target file exist
     if (diskfile->Open(filename))
     {
       // Yes. Record that fact.
       sourcefile->SetTargetExists(true);
-
+			
       // Remember that the DiskFile is the target file
       sourcefile->SetTargetFile(diskfile);
-
+			
       // Remember that we have processed this file
       bool success = diskFileMap.Insert(diskfile);
       assert(success);
+			
+			pthread_mutex_unlock (&fileIteratorMutex);
       // Do the actual verification
       if (!VerifyDataFile(diskfile, sourcefile))
-        finalresult = false;
-
+        rv = false;
+			
       // We have finished with the file for now
       diskfile->Close();
-
+			pthread_mutex_lock (&fileIteratorMutex);
+	
       // Find out how much data we have found
       UpdateVerificationResults();
-    }
+    } // End file exists
     else
     {
       // The file does not exist.
-      delete diskfile;
+			pthread_mutex_unlock (&fileIteratorMutex);
 
+      delete diskfile;
+			
       if (noiselevel > CommandLine::nlSilent)
       {
         string path;
         string name;
         DiskFile::SplitFilename(filename, path, name);
-
+				
+				pthread_mutex_lock (&fileIteratorMutex);
         cout << "Target: \"" << name << "\" - missing." << endl;
+				pthread_mutex_unlock (&fileIteratorMutex);
       }
-    }
-
-    ++sf;
-  }
+			pthread_mutex_lock (&fileIteratorMutex);
+    } // End file does not exist
+  } // End while
+	pthread_mutex_unlock (&fileIteratorMutex);
 
-  return finalresult;
+	return rv;
 }
 
 // Scan any extra files specified on the command line
 bool Par2Repairer::VerifyExtraFiles(const list<CommandLine::ExtraFile> &extrafiles)
 {
-  for (ExtraFileIterator i=extrafiles.begin(); 
-       i!=extrafiles.end() && completefilecount<mainpacket->RecoverableFileCount(); 
-       ++i)
-  {
-    string filename = i->FileName();
+	bool rv = true;
+	// Supports scanning in multiple threads, one per CPU.
+	// First set up the iterator
+	extraFileIterator = extrafiles.begin ();
+
+	// Now launch one thread per CPU
+	pthread_t lSpawnedThreads [cMaxThreadsSupported];
+	unsigned int lNumSpawnedThreads = 0;
+  unsigned int lNumThreads = numCPUs;
+	if (lNumThreads > cMaxThreadsSupported)
+		lNumThreads = cMaxThreadsSupported;
+	
+	for (unsigned int lThreadNo = 0; lThreadNo < lNumThreads; lThreadNo++)
+	{
+		// Pass the address of the extrafiles list directly to the thread. We guarantee that
+		// the address remains valid as long as the thread runs.
+		VerifyExtraFileCollectionThreadParams *lThreadParams = 
+				(VerifyExtraFileCollectionThreadParams *) malloc (sizeof (VerifyExtraFileCollectionThreadParams));
+		if (!lThreadParams)
+		{
+			rv = false;
+			break;	// From the for loop.
+		}
+		lThreadParams->This = this;
+		lThreadParams->fileCollection = &extrafiles;
+		int lResult = pthread_create (lSpawnedThreads + lThreadNo, NULL,
+																	Par2Repairer::VerifyExtraFileCollectionFunc, lThreadParams);
+		if (lResult == 0)
+			lNumSpawnedThreads++;
+		else
+		{
+			// This is an error; don't start any more threads
+			rv = false;
+			break;	// From the for loop
+		}
+	} // end for number of threads to start
+	
+	// Now wait for the threads to finish
+	for (unsigned int lThreadNo = 0; lThreadNo < lNumSpawnedThreads; lThreadNo++)
+	{
+		void *lThreadResult;
+		int lResult = pthread_join(lSpawnedThreads [lThreadNo], &lThreadResult);
+		assert (lResult == 0);
+		rv = rv && (lThreadResult != NULL);
+	}
+		
+	return rv;
+}
 
+// Function to support multi-threading
+bool Par2Repairer::VerifyExtraFileCollection (const list<CommandLine::ExtraFile> &extrafiles)
+{
+	// This function goes through the files in extrafiles. Multiple threads can run this same
+	// function simultaneously, therefore these threads have a shared iterator, extraFileIterator,
+	// which must have been set up before the first thread is launched.
+	
+	pthread_mutex_lock (&fileIteratorMutex);
+  while (extraFileIterator != extrafiles.end () && completefilecount < mainpacket->RecoverableFileCount())
+  {
+    string filename = extraFileIterator->FileName();
+		extraFileIterator++;
+		
     // If the filename does not include ".par2" we are interested in it.
     if (string::npos == filename.find(".par2") &&
         string::npos == filename.find(".PAR2"))
     {
       filename = DiskFile::GetCanonicalPathname(filename);
-
+			
       // Has this file already been dealt with
       if (diskFileMap.Find(filename) == 0)
       {
         DiskFile *diskfile = new DiskFile;
-
+				
         // Does the file exist
         if (!diskfile->Open(filename))
         {
           delete diskfile;
           continue;
         }
-
+				
         // Remember that we have processed this file
         bool success = diskFileMap.Insert(diskfile);
         assert(success);
-
+				
         // Do the actual verification
+				pthread_mutex_unlock (&fileIteratorMutex);
         VerifyDataFile(diskfile, 0);
         // Ignore errors
-
+				
         // We have finished with the file for now
         diskfile->Close();
-
+				pthread_mutex_lock (&fileIteratorMutex);
+				
         // Find out how much data we have found
         UpdateVerificationResults();
-      }
-    }
-  }
-
-  return true;
+				
+        /* If we have a complete set of files now, shortcut the loop. Just looking
+					at completefilecount + renamedfilecount ensures we continue scanning files until
+					we are sure a real repair is necessary. The alternative, calling CheckVerificationResults,
+					results in a start of the repair as soon as we have enough data, even if some more files
+					might easily have been renamed. As scanning is MUCH quicker than repairing, use the
+					former approach. */
+        if (completefilecount + renamedfilecount >= mainpacket->RecoverableFileCount())
+					//if (CheckVerificationResults (1)) // Silent verification (alternative)
+					break;    // From the for loop, because we CAN repair now
+      } // end if did not find file in map
+    } // end if filename does not contain par2
+  } // end for
+	
+	pthread_mutex_unlock (&fileIteratorMutex);
+
+  return true;	
 }
 
 // Attempt to match the data in the DiskFile with the source file
@@ -1472,6 +1709,8 @@ bool Par2Repairer::ScanDataFile(DiskFile                *diskfile,    // [in]
   // Whilst we have not reached the end of the file
   while (filechecksummer.Offset() < diskfile->FileSize())
   {
+		// Define MPDL to suppress all percentages. This speeds up things considerably.
+#ifndef MPDL
     if (noiselevel > CommandLine::nlQuiet)
     {
       // Update a progress indicator
@@ -1482,6 +1721,7 @@ bool Par2Repairer::ScanDataFile(DiskFile                *diskfile,    // [in]
         cout << "Scanning: \"" << shortname << "\": " << newfraction/10 << '.' << newfraction%10 << "%\r" << flush;
       }
     }
+#endif
 
     // If we fail to find a match, it might be because it was a duplicate of a block
     // that we have already found.
@@ -1799,7 +2039,7 @@ void Par2Repairer::UpdateVerificationResults(void)
 }
 
 // Check the verification results and report the results 
-bool Par2Repairer::CheckVerificationResults(void)
+bool Par2Repairer::CheckVerificationResults(int aSilent /* = 0*/)
 {
   // Is repair needed
   if (completefilecount < mainpacket->RecoverableFileCount() ||
@@ -1807,62 +2047,71 @@ bool Par2Repairer::CheckVerificationResults(void)
       damagedfilecount > 0 ||
       missingfilecount > 0)
   {
-    if (noiselevel > CommandLine::nlSilent)
-      cout << "Repair is required." << endl;
-    if (noiselevel > CommandLine::nlQuiet)
+    if (!aSilent)
     {
-      if (renamedfilecount > 0) cout << renamedfilecount << " file(s) have the wrong name." << endl;
-      if (missingfilecount > 0) cout << missingfilecount << " file(s) are missing." << endl;
-      if (damagedfilecount > 0) cout << damagedfilecount << " file(s) exist but are damaged." << endl;
-      if (completefilecount > 0) cout << completefilecount << " file(s) are ok." << endl;
-
-      cout << "You have " << availableblockcount 
-           << " out of " << sourceblockcount 
-           << " data blocks available." << endl;
-      if (recoverypacketmap.size() > 0)
-        cout << "You have " << (u32)recoverypacketmap.size() 
-             << " recovery blocks available." << endl;
+        if (noiselevel > CommandLine::nlSilent)
+          cout << "Repair is required." << endl;
+        if (noiselevel > CommandLine::nlQuiet)
+        {
+          if (renamedfilecount > 0) cout << renamedfilecount << " file(s) have the wrong name." << endl;
+          if (missingfilecount > 0) cout << missingfilecount << " file(s) are missing." << endl;
+          if (damagedfilecount > 0) cout << damagedfilecount << " file(s) exist but are damaged." << endl;
+          if (completefilecount > 0) cout << completefilecount << " file(s) are ok." << endl;
+
+          cout << "You have " << availableblockcount 
+               << " out of " << sourceblockcount 
+               << " data blocks available." << endl;
+          if (recoverypacketmap.size() > 0)
+            cout << "You have " << (u32)recoverypacketmap.size() 
+                 << " recovery blocks available." << endl;
+        }
     }
 
     // Is repair possible
     if (recoverypacketmap.size() >= missingblockcount)
     {
-      if (noiselevel > CommandLine::nlSilent)
-        cout << "Repair is possible." << endl;
-
-      if (noiselevel > CommandLine::nlQuiet)
+      if (!aSilent)
       {
-        if (recoverypacketmap.size() > missingblockcount)
-          cout << "You have an excess of " 
-               << (u32)recoverypacketmap.size() - missingblockcount
-               << " recovery blocks." << endl;
-
-        if (missingblockcount > 0)
-          cout << missingblockcount
-               << " recovery blocks will be used to repair." << endl;
-        else if (recoverypacketmap.size())
-          cout << "None of the recovery blocks will be used for the repair." << endl;
-      }
+          if (noiselevel > CommandLine::nlSilent)
+            cout << "Repair is possible." << endl;
 
+          if (noiselevel > CommandLine::nlQuiet)
+          {
+            if (recoverypacketmap.size() > missingblockcount)
+              cout << "You have an excess of " 
+                   << (u32)recoverypacketmap.size() - missingblockcount
+                   << " recovery blocks." << endl;
+
+            if (missingblockcount > 0)
+              cout << missingblockcount
+                   << " recovery blocks will be used to repair." << endl;
+            else if (recoverypacketmap.size())
+              cout << "None of the recovery blocks will be used for the repair." << endl;
+          }
+      }
       return true;
     }
     else
     {
-      if (noiselevel > CommandLine::nlSilent)
+      if (!aSilent)
       {
-        cout << "Repair is not possible." << endl;
-        cout << "You need " << missingblockcount - recoverypacketmap.size()
-             << " more recovery blocks to be able to repair." << endl;
+          if (noiselevel > CommandLine::nlSilent)
+          {
+            cout << "Repair is not possible." << endl;
+            cout << "You need " << missingblockcount - recoverypacketmap.size()
+                 << " more recovery blocks to be able to repair." << endl;
+          }
       }
-
       return false;
     }
   }
   else
   {
-    if (noiselevel > CommandLine::nlSilent)
-      cout << "All files are correct, repair is not required." << endl;
-
+    if (!aSilent)
+    {
+        if (noiselevel > CommandLine::nlSilent)
+          cout << "All files are correct, repair is not required." << endl;
+    }
     return true;
   }
 
@@ -2187,28 +2436,9 @@ bool Par2Repairer::ProcessData(u64 blockoffset, size_t blocklength)
         ++copyblock;
       }
 
-      // For each output block
-      for (u32 outputindex=0; outputindex<missingblockcount; outputindex++)
-      {
-        // Select the appropriate part of the output buffer
-        void *outbuf = &((u8*)outputbuffer)[chunksize * outputindex];
-
-        // Process the data
-        rs.Process(blocklength, inputindex, inputbuffer, outputindex, outbuf);
-
-        if (noiselevel > CommandLine::nlQuiet)
-        {
-          // Update a progress indicator
-          u32 oldfraction = (u32)(1000 * progress / totaldata);
-          progress += blocklength;
-          u32 newfraction = (u32)(1000 * progress / totaldata);
-
-          if (oldfraction != newfraction)
-          {
-            cout << "Repairing: " << newfraction/10 << '.' << newfraction%10 << "%\r" << flush;
-          }
-        }
-      }
+			// Function to process things in multiple threads if appropariate
+			if (!this->RepairMissingBlocks (blocklength, inputindex))
+				return false;
 
       ++inputblock;
       ++inputindex;
@@ -2300,7 +2530,127 @@ bool Par2Repairer::ProcessData(u64 blockoffset, size_t blocklength)
   return true;
 }
 
-// Verify that all of the reconstructed target files are now correct
+//-----------------------------------------------------------------------------
+bool Par2Repairer::RepairMissingBlocks (size_t blocklength, u32 inputindex)
+{
+	// Used from within ProcessData.
+	/*
+	 * I re-designed this part to become multi-threaded, so it can benefit from a machine
+	 * with multiple processors (or multiple cores). This becomes more and more common 
+	 * and will soon be the standard.
+	 * Depending on the number of threads required, the total range of blocks to
+	 * be processed (0 to missingblockcount - 1), is subdivided into a number of ranges. 
+	 * Each range is delegated to a separate thread. If the number of missing blocks is less
+	 * than the number of threads requested, too bad, then we leave one or more processors
+	 * unused. On the other hand, in that case the repair efforts are probably not very high
+	 * anyway.
+	 * Note that the main thread (this one) also takes part, so when the max number of threads
+	 * is 1, effectively nothing special happens.
+	 * Thread synchronization is pretty trivial. All threads use the same, immutable input
+	 * buffer, and they all write to separate parts of the output buffer. The only shared
+	 * resource is the progression, which is reported by each thread individually. This is
+	 * protected using a simple non-recursive mutex.
+	 * This function (RepairMissingBlocks) exits when all spawned threads have finished.
+	 */
+
+	if (missingblockcount == 0)
+		return true;		// Nothing to do, actually
+
+	bool rv = true;		// Optimistic default
+	pthread_t lSpawnedThreads [cMaxThreadsSupported - 1];
+  unsigned int lNumThreads = numCPUs;
+	if (lNumThreads > cMaxThreadsSupported)
+		lNumThreads = cMaxThreadsSupported;
+
+	// First, establish the number of blocks to be processed by each thread. Of course the last
+	// one started might get some less...
+	int lNumBlocksPerThread = (missingblockcount - 1) / lNumThreads + 1;		// Round up
+	u32 lCurrentStartBlockNo = 0;
+	u32 lNumSpawnedThreads = 0;
+
+	while (lCurrentStartBlockNo < missingblockcount)
+	{
+		u32 lNextStartBlockNo = lCurrentStartBlockNo + lNumBlocksPerThread;
+		if (lNextStartBlockNo > missingblockcount)
+			lNextStartBlockNo = missingblockcount;		// Constrain
+		// The first bunches run in separate threads; the last one in the main thread.
+		if (lNextStartBlockNo == missingblockcount)
+		{
+			// This is the last one
+			this->RepairMissingBlockRange (blocklength, inputindex, lCurrentStartBlockNo, lNextStartBlockNo);
+		}
+		else
+		{
+			assert (lNumSpawnedThreads < lNumThreads - 1);
+			// Make a new thread. Put the parameters, as well as our "this" pointer, in an allocated struct;
+			// the thread will free the strct after it is done with it.
+			RepairThreadParams *lParams = (RepairThreadParams *) malloc (sizeof (RepairThreadParams));
+			if (!lParams)
+			{
+				rv = false;
+				break;				// Should really not happen!
+			}
+			lParams->This = this;
+			lParams->blocklength = blocklength;
+			lParams->inputindex = inputindex;
+			lParams->aStartBlockNo = lCurrentStartBlockNo;
+			lParams->aEndBlockNo = lNextStartBlockNo;
+			int lResult = pthread_create (lSpawnedThreads + lNumSpawnedThreads, NULL,
+																		Par2Repairer::RepairMissingBlockRangeFunc, lParams);
+			assert (lResult == 0);
+			if (lResult == 0)
+				lNumSpawnedThreads++;		// So we know which ones are valid in lSpawnedThreads
+			else
+			{
+				rv = false;		// Don't expect this to really happen
+				break;
+			}
+		}
+		lCurrentStartBlockNo = lNextStartBlockNo;
+	}
+	// Wait till all the spawned threads have finished.
+	for (u32 i = 0; i < lNumSpawnedThreads; i++)
+	{
+		int lResult = pthread_join (lSpawnedThreads [i], NULL);
+		assert (lResult == 0);
+	}
+	return rv;
+}
+
+//-----------------------------------------------------------------------------
+void Par2Repairer::RepairMissingBlockRange (size_t blocklength, u32 inputindex, u32 aStartBlockNo, u32 aEndBlockNo)
+{
+	// This function runs in multiple threads.
+	// For each output block
+	for (u32 outputindex=aStartBlockNo; outputindex<aEndBlockNo; outputindex++)
+	{
+		// Select the appropriate part of the output buffer
+		void *outbuf = &((u8*)outputbuffer)[chunksize * outputindex];
+		
+		// Process the data
+		rs.Process(blocklength, inputindex, inputbuffer, outputindex, outbuf);
+		
+		if (noiselevel > CommandLine::nlQuiet)
+		{
+			// Update a progress indicator. This is thread-safe with a simple mutex
+			pthread_mutex_lock (&progressMutex);
+			progress += blocklength;
+			u32 newfraction = (u32)(1000 * progress / totaldata);
+			
+			// Only report "Repairing" when a certain amount of progress has been made
+			// since last time, or when the progress is 100%
+			if ((newfraction - previouslyReportedProgress >= 10) || (newfraction == 1000))
+			{
+				cout << "Repairing: " << newfraction/10 << '.' << newfraction%10 << "%\r" << flush;
+				previouslyReportedProgress = newfraction;
+			}
+			pthread_mutex_unlock (&progressMutex);
+		}
+	}
+}
+
+// Verify that all of the reconstructed target files are now correct.
+// Do this in multiple threads if appropriate (1 thread per processor).
 bool Par2Repairer::VerifyTargetFiles(void)
 {
   bool finalresult = true;
@@ -2308,18 +2658,61 @@ bool Par2Repairer::VerifyTargetFiles(void)
   // Verify the target files in alphabetical order
   sort(verifylist.begin(), verifylist.end(), SortSourceFilesByFileName);
 
-  // Iterate through each file in the verification list
-  for (vector<Par2RepairerSourceFile*>::iterator sf = verifylist.begin();
-       sf != verifylist.end();
-       ++sf)
+	// Initialize the iterator and launch the threads
+	targetFileIterator = verifylist.begin();
+	pthread_t lSpawnedThreads [cMaxThreadsSupported];
+	unsigned int lNumSpawnedThreads = 0;
+	unsigned int lNumThreads = numCPUs;
+	if (lNumThreads > cMaxThreadsSupported)
+		lNumThreads = cMaxThreadsSupported;
+		
+	for (unsigned int lThreadNo = 0; lThreadNo < lNumThreads; lThreadNo++)
+	{
+		int lResult = pthread_create (lSpawnedThreads + lThreadNo, NULL,
+																	Par2Repairer::VerifyFilesInVerifyListFunc, (void *) this);
+		if (lResult == 0)
+			lNumSpawnedThreads++;
+		else
+		{
+			// This is an error; don't start any more threads
+			finalresult = false;
+			break;	// From the for loop
+		}
+	} // end for
+	
+	// OK, we started all; now wait till all spawned threads have finished. The return value of
+	// each thread determines our return value: we AND it with finalresult, so in order to return
+	// true, all operations must succeed.
+	for (unsigned int lThreadNo = 0; lThreadNo < lNumSpawnedThreads; lThreadNo++)
+	{
+		void *lThreadResult;
+		int lResult = pthread_join(lSpawnedThreads [lThreadNo], &lThreadResult);
+		assert (lResult == 0);
+		finalresult = finalresult && (lThreadResult != NULL);
+	}
+	
+  return finalresult;
+}
+
+// This function runs in multiple threads. It verifies the files in verifylist,
+// and uses a common iterator, targetFileIterator, which must have been set up before
+// the first thread is launched.
+bool Par2Repairer::VerifyFilesInVerifyList()
+{
+	bool rv = true;
+	pthread_mutex_lock (&fileIteratorMutex);
+	
+  while (targetFileIterator != verifylist.end())
   {
-    Par2RepairerSourceFile *sourcefile = *sf;
-    DiskFile *targetfile = sourcefile->GetTargetFile();
+    Par2RepairerSourceFile *sourcefile = *targetFileIterator++;
+		pthread_mutex_unlock (&fileIteratorMutex);
 
+    DiskFile *targetfile = sourcefile->GetTargetFile();
+		
     // Close the file
     if (targetfile->IsOpen())
       targetfile->Close();
-
+		
     // Mark all data blocks for the file as unknown
     vector<DataBlock>::iterator sb = sourcefile->SourceBlocks();
     for (u32 blocknumber=0; blocknumber<sourcefile->BlockCount(); blocknumber++)
@@ -2327,32 +2720,35 @@ bool Par2Repairer::VerifyTargetFiles(void)
       sb->ClearLocation();
       ++sb;
     }
-
+		
     // Say we don't have a complete version of the file
     sourcefile->SetCompleteFile(0);
-
+		
     // Re-open the target file
     if (!targetfile->Open())
     {
-      finalresult = false;
+      rv = false;
+			pthread_mutex_lock (&fileIteratorMutex);	// Prepare for loop start
       continue;
     }
-
+		
     // Verify the file again
     if (!VerifyDataFile(targetfile, sourcefile))
-      finalresult = false;
-
+      rv = false;
+		
     // Close the file again
     targetfile->Close();
-
+		
+		pthread_mutex_lock (&fileIteratorMutex);
     // Find out how much data we have found
     UpdateVerificationResults();
   }
+	pthread_mutex_unlock (&fileIteratorMutex);
 
-  return finalresult;
+  return rv;
 }
 
-// Delete all of the partly reconstructed files
+// Delete all of the partly reconstructed files.
 bool Par2Repairer::DeleteIncompleteTargetFiles(void)
 {
   vector<Par2RepairerSourceFile*>::iterator sf = verifylist.begin();
